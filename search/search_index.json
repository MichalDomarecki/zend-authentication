{
    "docs": [
        {
            "location": "/",
            "text": "zend-authentication\n\n\n\n\n\n\nThe \nZend\\Authentication\n component provides an API for authentication and\nincludes concrete authentication adapters for common use case scenarios.\n\n\n\n\nFile issues at https://github.com/zendframework/zend-authentication/issues\n\n\nDocumentation is at https://docs.zendframework.com/zend-authentication/",
            "title": "zend-authentication"
        },
        {
            "location": "/#zend-authentication",
            "text": "The  Zend\\Authentication  component provides an API for authentication and\nincludes concrete authentication adapters for common use case scenarios.   File issues at https://github.com/zendframework/zend-authentication/issues  Documentation is at https://docs.zendframework.com/zend-authentication/",
            "title": "zend-authentication"
        },
        {
            "location": "/intro/",
            "text": "Introduction\n\n\nzend-authentication provides an API for authentication and includes concrete\nauthentication adapters for common use case scenarios.\n\n\nzend-authentication is concerned only with \nauthentication\n and not with\n\nauthorization\n.  Authentication is loosely defined as determining whether an\nentity actually is what it purports to be (i.e., identification), based on some\nset of credentials. Authorization, the process of deciding whether to allow an\nentity access to, or to perform operations upon, other entities is outside the\nscope of \nZend\\Authentication\n. For more information about authorization and\naccess control with Zend Framework, please see the\n\nzend-permissions-acl\n or\n\nzend-permissions-rbac\n\ncomponents.\n\n\n\n\nAuthenticationService\n\n\nThere is no \nZend\\Authentication\\Authentication\n class; instead the class\n\nZend\\Authentication\\AuthenticationService\n is provided. This class uses the\ncomposed authentication adapter and persistent storage backend.\n\n\n\n\nUsage\n\n\nThere are two approaches to using zend-authentication adapters:\n\n\n\n\nindirectly, through \nZend\\Authentication\\AuthenticationService::authenticate()\n\n\ndirectly, through the adapter's \nauthenticate()\n method\n\n\n\n\nThe following example illustrates how to use an adapter indirectly, through the\nuse of the \nZend\\Authentication\\AuthenticationService\n class:\n\n\nuse My\\Auth\\Adapter;\nuse Zend\\Authentication\\AuthenticationService;\n\n// Instantiate the authentication service:\n$auth = new AuthenticationService();\n\n// Instantiate the authentication adapter:\n$authAdapter = new Adapter($username, $password);\n\n// Attempt authentication, saving the result:\n$result = $auth->authenticate($authAdapter);\n\nif (! $result->isValid()) {\n    // Authentication failed; print the reasons why:\n    foreach ($result->getMessages() as $message) {\n        echo \"$message\\n\";\n    }\n} else {\n    // Authentication succeeded; the identity ($username) is stored\n    // in the session:\n    // $result->getIdentity() === $auth->getIdentity()\n    // $result->getIdentity() === $username\n}\n\n\n\nAfter a successful authentication attempt, subsequent requests can query the\nauthentication service to determine if an identity is present, and, if so,\nretrieve it:\n\n\nif ($auth->hasIdentity()) {\n    // Identity exists; get it\n    $identity = $auth->getIdentity();\n}\n\n\n\nTo remove the identity from persistent storage, use the \nclearIdentity()\n\nmethod. This typically would be used for implementing an application \"logout\"\noperation:\n\n\n$auth->clearIdentity();\n\n\n\nWhen the automatic use of persistent storage is inappropriate for a particular\nuse case, a developer may bypass the use of the\n\nZend\\Authentication\\AuthenticationService\n class, using an adapter class\ndirectly. Direct use of an adapter class involves configuring and preparing an\nadapter object and then calling its \nauthenticate()\n method. Adapter-specific\ndetails are discussed in the documentation for each adapter. The following\nexample directly utilizes the fictional \nMy\\Auth\\Adapter\n from the above\nexamples:\n\n\nuse My\\Auth\\Adapter;\n\n// Set up the authentication adapter:\n$authAdapter = new Adapter($username, $password);\n\n// Attempt authentication, saving the result:\n$result = $authAdapter->authenticate();\n\nif (! $result->isValid()) {\n    // Authentication failed; print the reasons why\n    foreach ($result->getMessages() as $message) {\n        echo \"$message\\n\";\n    }\n} else {\n    // Authentication succeeded\n    // $result->getIdentity() === $username\n}",
            "title": "Intro"
        },
        {
            "location": "/intro/#introduction",
            "text": "zend-authentication provides an API for authentication and includes concrete\nauthentication adapters for common use case scenarios.  zend-authentication is concerned only with  authentication  and not with authorization .  Authentication is loosely defined as determining whether an\nentity actually is what it purports to be (i.e., identification), based on some\nset of credentials. Authorization, the process of deciding whether to allow an\nentity access to, or to perform operations upon, other entities is outside the\nscope of  Zend\\Authentication . For more information about authorization and\naccess control with Zend Framework, please see the zend-permissions-acl  or zend-permissions-rbac \ncomponents.",
            "title": "Introduction"
        },
        {
            "location": "/intro/#authenticationservice",
            "text": "There is no  Zend\\Authentication\\Authentication  class; instead the class Zend\\Authentication\\AuthenticationService  is provided. This class uses the\ncomposed authentication adapter and persistent storage backend.",
            "title": "AuthenticationService"
        },
        {
            "location": "/intro/#usage",
            "text": "There are two approaches to using zend-authentication adapters:   indirectly, through  Zend\\Authentication\\AuthenticationService::authenticate()  directly, through the adapter's  authenticate()  method   The following example illustrates how to use an adapter indirectly, through the\nuse of the  Zend\\Authentication\\AuthenticationService  class:  use My\\Auth\\Adapter;\nuse Zend\\Authentication\\AuthenticationService;\n\n// Instantiate the authentication service:\n$auth = new AuthenticationService();\n\n// Instantiate the authentication adapter:\n$authAdapter = new Adapter($username, $password);\n\n// Attempt authentication, saving the result:\n$result = $auth->authenticate($authAdapter);\n\nif (! $result->isValid()) {\n    // Authentication failed; print the reasons why:\n    foreach ($result->getMessages() as $message) {\n        echo \"$message\\n\";\n    }\n} else {\n    // Authentication succeeded; the identity ($username) is stored\n    // in the session:\n    // $result->getIdentity() === $auth->getIdentity()\n    // $result->getIdentity() === $username\n}  After a successful authentication attempt, subsequent requests can query the\nauthentication service to determine if an identity is present, and, if so,\nretrieve it:  if ($auth->hasIdentity()) {\n    // Identity exists; get it\n    $identity = $auth->getIdentity();\n}  To remove the identity from persistent storage, use the  clearIdentity() \nmethod. This typically would be used for implementing an application \"logout\"\noperation:  $auth->clearIdentity();  When the automatic use of persistent storage is inappropriate for a particular\nuse case, a developer may bypass the use of the Zend\\Authentication\\AuthenticationService  class, using an adapter class\ndirectly. Direct use of an adapter class involves configuring and preparing an\nadapter object and then calling its  authenticate()  method. Adapter-specific\ndetails are discussed in the documentation for each adapter. The following\nexample directly utilizes the fictional  My\\Auth\\Adapter  from the above\nexamples:  use My\\Auth\\Adapter;\n\n// Set up the authentication adapter:\n$authAdapter = new Adapter($username, $password);\n\n// Attempt authentication, saving the result:\n$result = $authAdapter->authenticate();\n\nif (! $result->isValid()) {\n    // Authentication failed; print the reasons why\n    foreach ($result->getMessages() as $message) {\n        echo \"$message\\n\";\n    }\n} else {\n    // Authentication succeeded\n    // $result->getIdentity() === $username\n}",
            "title": "Usage"
        },
        {
            "location": "/adapter/intro/",
            "text": "Adapters Introduction\n\n\nzend-authentication adapters are used to authenticate against a particular type\nof authentication service, such as LDAP, RDBMS, or file-based storage. Different\nadapters are likely to have vastly different options and behaviors, but some\nbasic things are common among authentication adapters. For example, accepting\nauthentication credentials (including a purported identity), performing queries\nagainst the authentication service, and returning results are common to\nzend-authentication adapters.\n\n\nAdapterInterface\n\n\nEach adapter implements \nZend\\Authentication\\Adapter\\AdapterInterface\n.  This\ninterface defines one method, \nauthenticate()\n, which provides the\nimplementation for performing an authentication query. Each adapter class must\nbe prepared prior to calling \nauthenticate()\n; such adapter preparation might\ninclude setting up credentials from user input (e.g., username and password), or\ndefining values for adapter-specific configuration options, such as database\nconnection settings for a database table adapter.\n\n\nThe following is an example authentication adapter that requires a username and\npassword to be set for authentication. Other details, such as how the\nauthentication service is queried, have been omitted for brevity:\n\n\n<?php\nnamespace My\\Auth;\n\nuse Zend\\Authentication\\Adapter\\AdapterInterface;\n\nclass Adapter implements AdapterInterface\n{\n    /**\n     * Sets username and password for authentication\n     *\n     * @return void\n     */\n    public function __construct($username, $password)\n    {\n        // ...\n    }\n\n    /**\n     * Performs an authentication attempt\n     *\n     * @return \\Zend\\Authentication\\Result\n     * @throws \\Zend\\Authentication\\Adapter\\Exception\\ExceptionInterface\n     *     If authentication cannot be performed\n     */\n    public function authenticate()\n    {\n        // ...\n    }\n}\n\n\n\nAs indicated in its docblock, \nauthenticate()\n must return an instance of\n\nZend\\Authentication\\Result\n (or of a class derived from\n\nZend\\Authentication\\Result\n). If performing an authentication query is\nimpossible, \nauthenticate()\n should throw an exception that derives from\n\nZend\\Authentication\\Adapter\\Exception\\ExceptionInterface\n.\n\n\nResults\n\n\nAuthentication adapters return an instance of \nZend\\Authentication\\Result\n from\n\nauthenticate()\n in order to represent the results of an authentication attempt.\nAdapters populate the \nZend\\Authentication\\Result\n object upon construction:\n\n\nnamespace Zend\\Authentication;\n\nclass Result\n{\n    /**\n     * @param int $code\n     * @param mixed $identity\n     * @param array $messages\n     */\n    public function __construct($code, $identity, array $messages = []);\n}\n\n\n\nwhere:\n\n\n\n\n$code\n is an integer indicating the result status. Typically you will use one\n  of the constants defined in the \nResult\n class to provide this; a table\n  follows detailing those.\n\n\n$identity\n is the value representing the authenticated identity. This may be\n  any PHP type; typically you will see a string username or token, or an object\n  type specific to the application or login module you utilize. When the result\n  represents a failure to authenticate, this will often be null; some systems\n  will provide a default identity in such cases.\n\n\n$messages\n is an array of authentication failure messages.\n\n\n\n\nThe following result codes are available:\n\n\nnamespace Zend\\Authentication;\n\nclass Result\n{\n    const SUCCESS = 1;\n    const FAILURE = 0;\n    const FAILURE_IDENTITY_NOT_FOUND = -1;\n    const FAILURE_IDENTITY_AMBIGUOUS = -2;\n    const FAILURE_CREDENTIAL_INVALID = -3;\n    const FAILURE_UNCATEGORIZED = -4;\n}\n\n\n\nNote that success is a truthy value, while failure of any sort is a falsy value.\n\n\nResults provide the following four user-facing operations:\n\n\n\n\nisValid()\n returns \nTRUE\n if and only if the result represents a successful\n  authentication attempt.\n\n\ngetCode()\n returns the \nZend\\Authentication\\Result\n constant identifier\n  associated with the specific result. This may be used in situations where the\n  developer wishes to distinguish among several authentication result types.\n  This allows developers to maintain detailed authentication result statistics,\n  for example. Another use of this feature is to provide specific, customized\n  messages to users for usability reasons, though developers are encouraged to\n  consider the risks of providing such detailed reasons to users, instead of a\n  general authentication failure message. For more information, see the notes\n  below.\n\n\ngetIdentity()\n returns the identity of the authentication attempt.\n\n\ngetMessages()\n returns an array of messages regarding a failed authentication\n  attempt.\n\n\n\n\nA developer may wish to branch based on the type of authentication result in\norder to perform more specific operations. Some operations developers might find\nuseful are locking accounts after too many unsuccessful password attempts,\nflagging an IP address after too many nonexistent identities are attempted, and\nproviding specific, customized authentication result messages to the user.\n\n\nThe following example illustrates how a developer may branch on the result code:\n\n\n$result = $authenticationService->authenticate($adapter);\n\nswitch ($result->getCode()) {\n\n    case Result::FAILURE_IDENTITY_NOT_FOUND:\n        /** do stuff for nonexistent identity **/\n        break;\n\n    case Result::FAILURE_CREDENTIAL_INVALID:\n        /** do stuff for invalid credential **/\n        break;\n\n    case Result::SUCCESS:\n        /** do stuff for successful authentication **/\n        break;\n\n    default:\n        /** do stuff for other failure **/\n        break;\n}",
            "title": "Intro"
        },
        {
            "location": "/adapter/intro/#adapters-introduction",
            "text": "zend-authentication adapters are used to authenticate against a particular type\nof authentication service, such as LDAP, RDBMS, or file-based storage. Different\nadapters are likely to have vastly different options and behaviors, but some\nbasic things are common among authentication adapters. For example, accepting\nauthentication credentials (including a purported identity), performing queries\nagainst the authentication service, and returning results are common to\nzend-authentication adapters.",
            "title": "Adapters Introduction"
        },
        {
            "location": "/adapter/intro/#adapterinterface",
            "text": "Each adapter implements  Zend\\Authentication\\Adapter\\AdapterInterface .  This\ninterface defines one method,  authenticate() , which provides the\nimplementation for performing an authentication query. Each adapter class must\nbe prepared prior to calling  authenticate() ; such adapter preparation might\ninclude setting up credentials from user input (e.g., username and password), or\ndefining values for adapter-specific configuration options, such as database\nconnection settings for a database table adapter.  The following is an example authentication adapter that requires a username and\npassword to be set for authentication. Other details, such as how the\nauthentication service is queried, have been omitted for brevity:  <?php\nnamespace My\\Auth;\n\nuse Zend\\Authentication\\Adapter\\AdapterInterface;\n\nclass Adapter implements AdapterInterface\n{\n    /**\n     * Sets username and password for authentication\n     *\n     * @return void\n     */\n    public function __construct($username, $password)\n    {\n        // ...\n    }\n\n    /**\n     * Performs an authentication attempt\n     *\n     * @return \\Zend\\Authentication\\Result\n     * @throws \\Zend\\Authentication\\Adapter\\Exception\\ExceptionInterface\n     *     If authentication cannot be performed\n     */\n    public function authenticate()\n    {\n        // ...\n    }\n}  As indicated in its docblock,  authenticate()  must return an instance of Zend\\Authentication\\Result  (or of a class derived from Zend\\Authentication\\Result ). If performing an authentication query is\nimpossible,  authenticate()  should throw an exception that derives from Zend\\Authentication\\Adapter\\Exception\\ExceptionInterface .",
            "title": "AdapterInterface"
        },
        {
            "location": "/adapter/intro/#results",
            "text": "Authentication adapters return an instance of  Zend\\Authentication\\Result  from authenticate()  in order to represent the results of an authentication attempt.\nAdapters populate the  Zend\\Authentication\\Result  object upon construction:  namespace Zend\\Authentication;\n\nclass Result\n{\n    /**\n     * @param int $code\n     * @param mixed $identity\n     * @param array $messages\n     */\n    public function __construct($code, $identity, array $messages = []);\n}  where:   $code  is an integer indicating the result status. Typically you will use one\n  of the constants defined in the  Result  class to provide this; a table\n  follows detailing those.  $identity  is the value representing the authenticated identity. This may be\n  any PHP type; typically you will see a string username or token, or an object\n  type specific to the application or login module you utilize. When the result\n  represents a failure to authenticate, this will often be null; some systems\n  will provide a default identity in such cases.  $messages  is an array of authentication failure messages.   The following result codes are available:  namespace Zend\\Authentication;\n\nclass Result\n{\n    const SUCCESS = 1;\n    const FAILURE = 0;\n    const FAILURE_IDENTITY_NOT_FOUND = -1;\n    const FAILURE_IDENTITY_AMBIGUOUS = -2;\n    const FAILURE_CREDENTIAL_INVALID = -3;\n    const FAILURE_UNCATEGORIZED = -4;\n}  Note that success is a truthy value, while failure of any sort is a falsy value.  Results provide the following four user-facing operations:   isValid()  returns  TRUE  if and only if the result represents a successful\n  authentication attempt.  getCode()  returns the  Zend\\Authentication\\Result  constant identifier\n  associated with the specific result. This may be used in situations where the\n  developer wishes to distinguish among several authentication result types.\n  This allows developers to maintain detailed authentication result statistics,\n  for example. Another use of this feature is to provide specific, customized\n  messages to users for usability reasons, though developers are encouraged to\n  consider the risks of providing such detailed reasons to users, instead of a\n  general authentication failure message. For more information, see the notes\n  below.  getIdentity()  returns the identity of the authentication attempt.  getMessages()  returns an array of messages regarding a failed authentication\n  attempt.   A developer may wish to branch based on the type of authentication result in\norder to perform more specific operations. Some operations developers might find\nuseful are locking accounts after too many unsuccessful password attempts,\nflagging an IP address after too many nonexistent identities are attempted, and\nproviding specific, customized authentication result messages to the user.  The following example illustrates how a developer may branch on the result code:  $result = $authenticationService->authenticate($adapter);\n\nswitch ($result->getCode()) {\n\n    case Result::FAILURE_IDENTITY_NOT_FOUND:\n        /** do stuff for nonexistent identity **/\n        break;\n\n    case Result::FAILURE_CREDENTIAL_INVALID:\n        /** do stuff for invalid credential **/\n        break;\n\n    case Result::SUCCESS:\n        /** do stuff for successful authentication **/\n        break;\n\n    default:\n        /** do stuff for other failure **/\n        break;\n}",
            "title": "Results"
        },
        {
            "location": "/adapter/dbtable/intro/",
            "text": "Database Table Authentication\n\n\nThe adapters under the \nZend\\Authentication\\Adapter\\DbTable\n provide the\nability to authenticate against credentials stored in a database table, with\ntwo approaches possible:\n\n\n\n\nusage of a \ncredential treatment\n function on the RDBMS server with the\n  provided credentials.\n\n\nexecution of a PHP callback on the identity returned by the RDBMS server.\n\n\n\n\nBecause each adapter requires an instance of \nZend\\Db\\Adapter\\Adapter\n to be\npassed to its constructor, each instance is bound to a particular database\nconnection.  Other configuration options may be set through the constructor and\nthrough instance methods, one for each option.\n\n\nZend\\Authentication\\Adapter\\DbTable\n class is deprecated\n\n\nThe concrete adapter \nZend\\Authentication\\Adapter\\DbTable\n has been\ndeprecated since 2.2.0, and its responsibilities have been split into two,\n\nZend\\Authentication\\Adapter\\DbTable\\CallbackCheck\n and\n\nZend\\Authentication\\Adapter\\DbTable\\CredentialTreatmentAdapter\n.\n\n\nIf you were using \nZend\\Authentication\\Adapter\\DbTable\n previously, you can\nreplace its usage with\n\nZend\\Authentication\\Adapter\\DbTable\\CredentialTreatmentAdapter\n, as the APIs\nare the same; \nDbTable\n extends \nCredentialTreatmentAdapter\n at this time.",
            "title": "Intro"
        },
        {
            "location": "/adapter/dbtable/intro/#database-table-authentication",
            "text": "The adapters under the  Zend\\Authentication\\Adapter\\DbTable  provide the\nability to authenticate against credentials stored in a database table, with\ntwo approaches possible:   usage of a  credential treatment  function on the RDBMS server with the\n  provided credentials.  execution of a PHP callback on the identity returned by the RDBMS server.   Because each adapter requires an instance of  Zend\\Db\\Adapter\\Adapter  to be\npassed to its constructor, each instance is bound to a particular database\nconnection.  Other configuration options may be set through the constructor and\nthrough instance methods, one for each option.",
            "title": "Database Table Authentication"
        },
        {
            "location": "/adapter/dbtable/intro/#zendauthenticationadapterdbtable-class-is-deprecated",
            "text": "The concrete adapter  Zend\\Authentication\\Adapter\\DbTable  has been\ndeprecated since 2.2.0, and its responsibilities have been split into two, Zend\\Authentication\\Adapter\\DbTable\\CallbackCheck  and Zend\\Authentication\\Adapter\\DbTable\\CredentialTreatmentAdapter .  If you were using  Zend\\Authentication\\Adapter\\DbTable  previously, you can\nreplace its usage with Zend\\Authentication\\Adapter\\DbTable\\CredentialTreatmentAdapter , as the APIs\nare the same;  DbTable  extends  CredentialTreatmentAdapter  at this time.",
            "title": "Zend\\Authentication\\Adapter\\DbTable class is deprecated"
        },
        {
            "location": "/adapter/dbtable/credential-treatment/",
            "text": "DbTable Credential Treatment\n\n\nZend\\Authentication\\Adapter\\DbTable\\CredentialTreatmentAdapter\n will execute a\nSQL query containing the provided identity and credentials, passing the\ncredentials to a \ncredential treatment\n function defined on the RDBMS server;\nif an identity is returned, authentication succeeds. Common credential\ntreatments include \nMD5()\n and \nPASSWORD()\n.\n\n\nConfiguration Options\n\n\nThe available configuration options include:\n\n\n\n\ntableName\n: This is the name of the database table that contains the\n  authentication credentials, and against which the database authentication\n  query is performed.\n\n\nidentityColumn\n: This is the name of the database table column used to\n  represent the identity.  The identity column must contain unique values, such\n  as a username or e-mail address.\n\n\ncredentialColumn\n: This is the name of the database table column used to\n  represent the credential. Under a simple identity and password authentication\n  scheme, the credential value corresponds to the password. See also the\n  \ncredentialTreatment\n option.\n\n\ncredentialTreatment\n: In many cases, passwords and other sensitive data\n  are encrypted, hashed, encoded, obscured, salted or otherwise treated through\n  some function or algorithm. By specifying a parameterized treatment string\n  with this method, such as '\nMD5(?)\n' or '\nPASSWORD(?)\n', a developer may\n  apply such arbitrary SQL upon input credential data. Since these functions\n  are specific to the underlying RDBMS, check the database manual for the\n  availability of such functions for your database system.\n\n\n\n\nBasic Usage\n\n\nAs explained above, the\n\nZend\\Authentication\\Adapter\\DbTable\\CredentialTreatmentAdapter\n constructor\nrequires an instance of \nZend\\Db\\Adapter\\Adapter\n that serves as the database\nconnection to which the authentication adapter instance is bound. First, the\ndatabase connection should be created.\n\n\nThe following code creates an adapter for an in-memory database, creates a\nsimple table schema, and inserts a row against which we can perform an\nauthentication query later. This example requires the PDO SQLite extension to\nbe available:\n\n\nuse Zend\\Db\\Adapter\\Adapter as DbAdapter;\n\n// Create a SQLite database connection\n$dbAdapter = new DbAdapter([\n    'driver'   => 'Pdo_Sqlite',\n    'database' => 'data/users.db',\n]);\n\n// Build a simple table creation query\n$sqlCreate = 'CREATE TABLE [users] ('\n    . '[id] INTEGER  NOT NULL PRIMARY KEY, '\n    . '[username] VARCHAR(50) UNIQUE NOT NULL, '\n    . '[password] VARCHAR(32) NULL, '\n    . '[real_name] VARCHAR(150) NULL)';\n\n// Create the authentication credentials table\n$dbAdapter->query($sqlCreate);\n\n// Build a query to insert a row for which authentication may succeed\n$sqlInsert = \"INSERT INTO users (username, password, real_name) \"\n    . \"VALUES ('my_username', 'my_password', 'My Real Name')\";\n\n// Insert the data\n$dbAdapter->query($sqlInsert);\n\n\n\nWith the database connection and table data available, an instance of\n\nZend\\Authentication\\Adapter\\DbTable\\CredentialTreatmentAdapter\n may be\ncreated. Configuration option values may be passed to the constructor or\ndeferred as parameters to setter methods after instantiation:\n\n\nuse Zend\\Authentication\\Adapter\\DbTable\\CredentialTreatmentAdapter as AuthAdapter;\n\n// Configure the instance with constructor parameters:\n$authAdapter = new AuthAdapter(\n    $dbAdapter,\n    'users',\n    'username',\n    'password'\n);\n\n// Or configure the instance with setter methods:\n$authAdapter = new AuthAdapter($dbAdapter);\n\n$authAdapter\n    ->setTableName('users')\n    ->setIdentityColumn('username')\n    ->setCredentialColumn('password');\n\n\n\nAt this point, the authentication adapter instance is ready to accept\nauthentication queries. In order to formulate an authentication query, the\ninput credential values are passed to the adapter prior to calling the\n\nauthenticate()\n method:\n\n\n// Set the input credential values (e.g., from a login form):\n$authAdapter\n    ->setIdentity('my_username')\n    ->setCredential('my_password');\n\n// Perform the authentication query, saving the result\n$result = $authAdapter->authenticate();\n\n\n\nIn addition to the availability of the \ngetIdentity()\n method upon the\nauthentication result object, \nZend\\Authentication\\Adapter\\DbTable\\CredentialTreatmentAdapter\n\nalso supports retrieving the table row upon authentication success:\n\n\n// Print the identity:\necho $result->getIdentity() . \"\\n\\n\";\n\n// Print the result row:\nprint_r($authAdapter->getResultRowObject());\n\n/* Output:\nmy_username\n\nArray\n(\n    [id] => 1\n    [username] => my_username\n    [password] => my_password\n    [real_name] => My Real Name\n)\n*/\n\n\n\nSince the table row contains the credential value, it is important to secure\nthe values against unintended access.\n\n\nWhen retrieving the result object, we can either specify what columns to\nreturn, or what columns to omit:\n\n\n// Specify the columns to return:\n$columnsToReturn = [\n    'id',\n    'username',\n    'real_name',\n];\nprint_r($authAdapter->getResultRowObject($columnsToReturn));\n\n/* Output:\n\nArray\n(\n   [id] => 1\n   [username] => my_username\n   [real_name] => My Real Name\n)\n*/\n\n// Or specify the columns to omit; when using this approach,\n// pass a null value as the first argument to getResultRowObject():\n$columnsToOmit = ['password'];\nprint_r($authAdapter->getResultRowObject(null, $columnsToOmit);\n\n/* Output:\n\nArray\n(\n   [id] => 1\n   [username] => my_username\n   [real_name] => My Real Name\n)\n*/\n\n\n\nAdvanced Usage\n\n\nWhile the primary purpose of zend-authentication is \nauthentication\n and not\n\nauthorization\n, there are a few instances and problems that toe the line\nbetween which domain they fit.  Depending on how you've decided to explain your\nproblem, it sometimes makes sense to solve what could look like an\nauthorization problem within the authentication adapter.\n\n\nBelow are a few examples showing how you can provide compound criteria to the\ncredential treatment to solve more complex problems.\n\n\nCheck for compromised user\n\n\nIn this scenario, we use the credential treatment \nMD5()\n, but also check to see\nthat the user has not been flagged as \"compromised\", which is a potential value\nof the \nstatus\n field for the user record.\n\n\nuse Zend\\Authentication\\Adapter\\DbTable\\CredentialTreatmentAdapter as AuthAdapter;\n\n// The status field value of an account is not equal to \"compromised\"\n$adapter = new AuthAdapter(\n    $db,\n    'users',\n    'username',\n    'password',\n    'MD5(?) AND status != \"compromised\"'\n);\n\n\n\nCheck for active user\n\n\nIn this example, we check to see if a user is active; this may be necessary\nif we require a user to login once over X days, or if we need to ensure that\nthey have followed a verification process.\n\n\nuse Zend\\Authentication\\Adapter\\DbTable\\CredentialTreatmentAdapter as AuthAdapter;\n\n// The active field value of an account is equal to \"TRUE\"\n$adapter = new AuthAdapter(\n    $db,\n    'users',\n    'username',\n    'password',\n    'MD5(?) AND active = \"TRUE\"'\n);\n\n\n\nSalting\n\n\nAnother scenario can be the implementation of a salting mechanism. Salting\nrefers to a technique for improving application security; it's based on the\nidea that concatenating a random string to every password makes it impossible\nto accomplish a successful brute force attack on the database using\npre-computed hash values from a dictionary.\n\n\nLet's modify our table to store our salt string:\n\n\n$sqlAlter = \"ALTER TABLE [users] \"\n    . \"ADD COLUMN [password_salt] \"\n    . \"AFTER [password]\";\n\n\n\nSalts should be created \nfor each user\n using a cryptographically sound pseudo-random number generator (CSPRNG). PHP 7 provides an implementation via \nrandom_bytes\n:\n\n\n$salt = random_bytes(32);\n\n\n\nFor earlier versions of PHP, use \nzend-math\n's \nZend\\Math\\Rand\n:\n\n\nuse Zend\\Math\\Rand;\n\n$salt = Rand::getBytes(32, true);\n\n\n\n(As of zend-math 2.7.0, \nRand::getBytes()\n will proxy to \nrandom_bytes()\n when\nrunning under PHP 7, making it a good, forwards-compatible solution for your\napplication.)\n\n\nDo this each time you create a user or update their password, and store it in the\n\npassword_salt\n column you created.\n\n\nNow let's build the adapter:\n\n\n$adapter = new AuthAdapter(\n$db,\n    'users',\n    'username',\n    'password',\n    \"MD5(CONCAT('staticSalt', ?, password_salt))\"\n);\n\n\n\n\n\nSalt security\n\n\nYou can improve security even more by using a static salt value hard coded\ninto your application. In the case that your database is compromised (e.g.\nby an SQL injection attack) but your web server is intact, your data is still\nunusable for the attacker.\n\n\nDefine the salt as an environment variable on your web server, and then\neither pull it from the environment, or assign it to a constant during\nbootstrap; pass the value to the credential treatment when creating your\nadapter.\n\n\nThe above example uses the value \"staticSalt\"; you should create a better\nsalt using one of the methods outlined above.\n\n\n\n\nAlter the SQL select directly\n\n\nAnother alternative is to use the \ngetDbSelect()\n method to retrieve the\n\nZend\\Db\\Sql\\Select\n instance associated with the adapter and modify it. (The\nmethod is common to all \nZend\\Authentication\\Adapter\\DbTable\n adapters.) The\n\nSelect\n instance is consumed by the \nauthenticate()\n routine when building the\nSQL to execute on the RDBMS server.  It is important to note that this method\nwill always return the same \nSelect\n instance regardless if \nauthenticate()\n\nhas been called or not; identity and credential values are passed to the\ninstance as placeholders.\n\n\nThis approach allows you to define a generic credential treatment, and then add\ncriteria later, potentially based on specific paths through the application.\n\n\nThe following uses the second example in this section, adding another \nWHERE\n\nclause to determine if the user is active in the system.\n\n\n// Create a basic adapter, with only an MD5() credential treatment:\n$adapter = new AuthAdapter(\n    $db,\n    'users',\n    'username',\n    'password',\n    'MD5(?)'\n);\n\n// Now retrieve the Select instance and modify it:\n$select = $adapter->getDbSelect();\n$select->where('active = \"TRUE\"');\n\n// Authenticate; this will include \"users.active = TRUE\" in the WHERE clause:\n$adapter->authenticate();",
            "title": "CredentialTreatmentAdapter"
        },
        {
            "location": "/adapter/dbtable/credential-treatment/#dbtable-credential-treatment",
            "text": "Zend\\Authentication\\Adapter\\DbTable\\CredentialTreatmentAdapter  will execute a\nSQL query containing the provided identity and credentials, passing the\ncredentials to a  credential treatment  function defined on the RDBMS server;\nif an identity is returned, authentication succeeds. Common credential\ntreatments include  MD5()  and  PASSWORD() .",
            "title": "DbTable Credential Treatment"
        },
        {
            "location": "/adapter/dbtable/credential-treatment/#configuration-options",
            "text": "The available configuration options include:   tableName : This is the name of the database table that contains the\n  authentication credentials, and against which the database authentication\n  query is performed.  identityColumn : This is the name of the database table column used to\n  represent the identity.  The identity column must contain unique values, such\n  as a username or e-mail address.  credentialColumn : This is the name of the database table column used to\n  represent the credential. Under a simple identity and password authentication\n  scheme, the credential value corresponds to the password. See also the\n   credentialTreatment  option.  credentialTreatment : In many cases, passwords and other sensitive data\n  are encrypted, hashed, encoded, obscured, salted or otherwise treated through\n  some function or algorithm. By specifying a parameterized treatment string\n  with this method, such as ' MD5(?) ' or ' PASSWORD(?) ', a developer may\n  apply such arbitrary SQL upon input credential data. Since these functions\n  are specific to the underlying RDBMS, check the database manual for the\n  availability of such functions for your database system.",
            "title": "Configuration Options"
        },
        {
            "location": "/adapter/dbtable/credential-treatment/#basic-usage",
            "text": "As explained above, the Zend\\Authentication\\Adapter\\DbTable\\CredentialTreatmentAdapter  constructor\nrequires an instance of  Zend\\Db\\Adapter\\Adapter  that serves as the database\nconnection to which the authentication adapter instance is bound. First, the\ndatabase connection should be created.  The following code creates an adapter for an in-memory database, creates a\nsimple table schema, and inserts a row against which we can perform an\nauthentication query later. This example requires the PDO SQLite extension to\nbe available:  use Zend\\Db\\Adapter\\Adapter as DbAdapter;\n\n// Create a SQLite database connection\n$dbAdapter = new DbAdapter([\n    'driver'   => 'Pdo_Sqlite',\n    'database' => 'data/users.db',\n]);\n\n// Build a simple table creation query\n$sqlCreate = 'CREATE TABLE [users] ('\n    . '[id] INTEGER  NOT NULL PRIMARY KEY, '\n    . '[username] VARCHAR(50) UNIQUE NOT NULL, '\n    . '[password] VARCHAR(32) NULL, '\n    . '[real_name] VARCHAR(150) NULL)';\n\n// Create the authentication credentials table\n$dbAdapter->query($sqlCreate);\n\n// Build a query to insert a row for which authentication may succeed\n$sqlInsert = \"INSERT INTO users (username, password, real_name) \"\n    . \"VALUES ('my_username', 'my_password', 'My Real Name')\";\n\n// Insert the data\n$dbAdapter->query($sqlInsert);  With the database connection and table data available, an instance of Zend\\Authentication\\Adapter\\DbTable\\CredentialTreatmentAdapter  may be\ncreated. Configuration option values may be passed to the constructor or\ndeferred as parameters to setter methods after instantiation:  use Zend\\Authentication\\Adapter\\DbTable\\CredentialTreatmentAdapter as AuthAdapter;\n\n// Configure the instance with constructor parameters:\n$authAdapter = new AuthAdapter(\n    $dbAdapter,\n    'users',\n    'username',\n    'password'\n);\n\n// Or configure the instance with setter methods:\n$authAdapter = new AuthAdapter($dbAdapter);\n\n$authAdapter\n    ->setTableName('users')\n    ->setIdentityColumn('username')\n    ->setCredentialColumn('password');  At this point, the authentication adapter instance is ready to accept\nauthentication queries. In order to formulate an authentication query, the\ninput credential values are passed to the adapter prior to calling the authenticate()  method:  // Set the input credential values (e.g., from a login form):\n$authAdapter\n    ->setIdentity('my_username')\n    ->setCredential('my_password');\n\n// Perform the authentication query, saving the result\n$result = $authAdapter->authenticate();  In addition to the availability of the  getIdentity()  method upon the\nauthentication result object,  Zend\\Authentication\\Adapter\\DbTable\\CredentialTreatmentAdapter \nalso supports retrieving the table row upon authentication success:  // Print the identity:\necho $result->getIdentity() . \"\\n\\n\";\n\n// Print the result row:\nprint_r($authAdapter->getResultRowObject());\n\n/* Output:\nmy_username\n\nArray\n(\n    [id] => 1\n    [username] => my_username\n    [password] => my_password\n    [real_name] => My Real Name\n)\n*/  Since the table row contains the credential value, it is important to secure\nthe values against unintended access.  When retrieving the result object, we can either specify what columns to\nreturn, or what columns to omit:  // Specify the columns to return:\n$columnsToReturn = [\n    'id',\n    'username',\n    'real_name',\n];\nprint_r($authAdapter->getResultRowObject($columnsToReturn));\n\n/* Output:\n\nArray\n(\n   [id] => 1\n   [username] => my_username\n   [real_name] => My Real Name\n)\n*/\n\n// Or specify the columns to omit; when using this approach,\n// pass a null value as the first argument to getResultRowObject():\n$columnsToOmit = ['password'];\nprint_r($authAdapter->getResultRowObject(null, $columnsToOmit);\n\n/* Output:\n\nArray\n(\n   [id] => 1\n   [username] => my_username\n   [real_name] => My Real Name\n)\n*/",
            "title": "Basic Usage"
        },
        {
            "location": "/adapter/dbtable/credential-treatment/#advanced-usage",
            "text": "While the primary purpose of zend-authentication is  authentication  and not authorization , there are a few instances and problems that toe the line\nbetween which domain they fit.  Depending on how you've decided to explain your\nproblem, it sometimes makes sense to solve what could look like an\nauthorization problem within the authentication adapter.  Below are a few examples showing how you can provide compound criteria to the\ncredential treatment to solve more complex problems.",
            "title": "Advanced Usage"
        },
        {
            "location": "/adapter/dbtable/credential-treatment/#check-for-compromised-user",
            "text": "In this scenario, we use the credential treatment  MD5() , but also check to see\nthat the user has not been flagged as \"compromised\", which is a potential value\nof the  status  field for the user record.  use Zend\\Authentication\\Adapter\\DbTable\\CredentialTreatmentAdapter as AuthAdapter;\n\n// The status field value of an account is not equal to \"compromised\"\n$adapter = new AuthAdapter(\n    $db,\n    'users',\n    'username',\n    'password',\n    'MD5(?) AND status != \"compromised\"'\n);",
            "title": "Check for compromised user"
        },
        {
            "location": "/adapter/dbtable/credential-treatment/#check-for-active-user",
            "text": "In this example, we check to see if a user is active; this may be necessary\nif we require a user to login once over X days, or if we need to ensure that\nthey have followed a verification process.  use Zend\\Authentication\\Adapter\\DbTable\\CredentialTreatmentAdapter as AuthAdapter;\n\n// The active field value of an account is equal to \"TRUE\"\n$adapter = new AuthAdapter(\n    $db,\n    'users',\n    'username',\n    'password',\n    'MD5(?) AND active = \"TRUE\"'\n);",
            "title": "Check for active user"
        },
        {
            "location": "/adapter/dbtable/credential-treatment/#salting",
            "text": "Another scenario can be the implementation of a salting mechanism. Salting\nrefers to a technique for improving application security; it's based on the\nidea that concatenating a random string to every password makes it impossible\nto accomplish a successful brute force attack on the database using\npre-computed hash values from a dictionary.  Let's modify our table to store our salt string:  $sqlAlter = \"ALTER TABLE [users] \"\n    . \"ADD COLUMN [password_salt] \"\n    . \"AFTER [password]\";  Salts should be created  for each user  using a cryptographically sound pseudo-random number generator (CSPRNG). PHP 7 provides an implementation via  random_bytes :  $salt = random_bytes(32);  For earlier versions of PHP, use  zend-math 's  Zend\\Math\\Rand :  use Zend\\Math\\Rand;\n\n$salt = Rand::getBytes(32, true);  (As of zend-math 2.7.0,  Rand::getBytes()  will proxy to  random_bytes()  when\nrunning under PHP 7, making it a good, forwards-compatible solution for your\napplication.)  Do this each time you create a user or update their password, and store it in the password_salt  column you created.  Now let's build the adapter:  $adapter = new AuthAdapter(\n$db,\n    'users',\n    'username',\n    'password',\n    \"MD5(CONCAT('staticSalt', ?, password_salt))\"\n);",
            "title": "Salting"
        },
        {
            "location": "/adapter/dbtable/credential-treatment/#salt-security",
            "text": "You can improve security even more by using a static salt value hard coded\ninto your application. In the case that your database is compromised (e.g.\nby an SQL injection attack) but your web server is intact, your data is still\nunusable for the attacker.  Define the salt as an environment variable on your web server, and then\neither pull it from the environment, or assign it to a constant during\nbootstrap; pass the value to the credential treatment when creating your\nadapter.  The above example uses the value \"staticSalt\"; you should create a better\nsalt using one of the methods outlined above.",
            "title": "Salt security"
        },
        {
            "location": "/adapter/dbtable/credential-treatment/#alter-the-sql-select-directly",
            "text": "Another alternative is to use the  getDbSelect()  method to retrieve the Zend\\Db\\Sql\\Select  instance associated with the adapter and modify it. (The\nmethod is common to all  Zend\\Authentication\\Adapter\\DbTable  adapters.) The Select  instance is consumed by the  authenticate()  routine when building the\nSQL to execute on the RDBMS server.  It is important to note that this method\nwill always return the same  Select  instance regardless if  authenticate() \nhas been called or not; identity and credential values are passed to the\ninstance as placeholders.  This approach allows you to define a generic credential treatment, and then add\ncriteria later, potentially based on specific paths through the application.  The following uses the second example in this section, adding another  WHERE \nclause to determine if the user is active in the system.  // Create a basic adapter, with only an MD5() credential treatment:\n$adapter = new AuthAdapter(\n    $db,\n    'users',\n    'username',\n    'password',\n    'MD5(?)'\n);\n\n// Now retrieve the Select instance and modify it:\n$select = $adapter->getDbSelect();\n$select->where('active = \"TRUE\"');\n\n// Authenticate; this will include \"users.active = TRUE\" in the WHERE clause:\n$adapter->authenticate();",
            "title": "Alter the SQL select directly"
        },
        {
            "location": "/adapter/dbtable/callback-check/",
            "text": "Callback Verification\n\n\nSome verification operations cannot be performed well on RDBMS servers. Other\ntimes, you may be unsure which RDBMS system you will be using long-term, and\nneed to ensure authentication will work consistently. For these situations, you\ncan use the \nZend\\Authentication\\Adapter\\DbTable\\CallbackCheckAdapter\n adapter.\nSimilar to the \nCredentialTreatmentAdapter\n, it\naccepts a table name, identity column, and credential column; however, instead\nof a credential treatment, it accepts a \ncredential validation callback\n that\nis executed when the database returns any matches, and which can be used to\nperform additional credential verifications.\n\n\nConfiguration options\n\n\nThe available configuration options include:\n\n\n\n\ntableName\n: This is the name of the database table that contains the\n  authentication credentials, and against which the database authentication\n  query is performed.\n\n\nidentityColumn\n: This is the name of the database table column used to\n  represent the identity.  The identity column must contain unique values, such\n  as a username or e-mail address.\n\n\ncredentialColumn\n: This is the name of the database table column used to\n  represent the credential. Under a simple identity and password authentication\n  scheme, the credential value corresponds to the password.\n\n\ncredentialValidationCallback\n: A PHP callable to execute when the database returns matches. The callback will receive:\n\n\nthe value of the \ncredentialColumn\n returned from the database\n\n\nthe credential that was used by the adapter during authentication\n\n\n\n\nBasic Usage\n\n\nMany databases do not provide functions that implement a cryptographically\nsecure hashing mechanism. Additionally, you may want to ensure that should you\nswitch database systems, hashing is consistent. This is a perfect use case for\nthe \nCallbackCheckAdapter\n adapter; you can implement the password hashing and\nverification within PHP instead.\n\n\nThe following code creates an adapter for an in-memory database, creates a\nsimple table schema, and inserts a row against which we can perform an\nauthentication query later. This example requires the PDO SQLite extension to\nbe available:\n\n\nuse Zend\\Db\\Adapter\\Adapter as DbAdapter;\n\n// Create a SQLite database connection\n$dbAdapter = new DbAdapter([\n    'driver'   => 'Pdo_Sqlite',\n    'database' => 'data/sqlite.db',\n]);\n\n// Build a simple table creation query\n$sqlCreate = 'CREATE TABLE [users] ('\n    . '[id] INTEGER  NOT NULL PRIMARY KEY, '\n    . '[username] VARCHAR(50) UNIQUE NOT NULL, '\n    . '[password] VARCHAR(255) NULL, '\n    . '[real_name] VARCHAR(150) NULL)';\n\n// Create the authentication credentials table\n$dbAdapter->query($sqlCreate);\n\n// Build a query to insert a row for which authentication may succeed\n$sqlInsert = \"INSERT INTO users (username, password, real_name) \"\n    . \"VALUES ('my_username', 'my_password', 'My Real Name')\";\n\n// Insert the data\n$dbAdapter->query($sqlInsert);\n\n\n\nAs you add users, you will need to create a hash of the password provided and\ninsert that into the database. For users on PHP 5.5+, you can use\n\npassword_hash()\n:\n\n\n$hash = password_hash($password, PASSWORD_DEFAULT);\n\n\n\n\n\nPassword hash length\n\n\nAs of the time of writing, PHP uses a bcrypt algorithm by default for hashing\npasswords with \npassword_hash()\n, and this produces 60 character strings. However,\nthe default may change over time, and php.net recommends using 255 character\nfields for storage to allow for larger hash sizes in the future.\n\n\n\n\nTo verify a password, we'll create a callback that uses\n\npassword_verify()\n:\n\n\n$passwordValidation = function ($hash, $password) {\n    return password_verify($password, $hash);\n};\n\n\n\nNow that we have the database connection and a password validation function,\nwe can create our \nZend\\Authentication\\Adapter\\DbTable\\CallbackCheckAdapter\n adapter\ninstance, passing the options to the constructor or later via setter methods:\n\n\nuse Zend\\Authentication\\Adapter\\DbTable\\CallbackCheckAdapter as AuthAdapter;\n\n// Configure the instance with constructor parameters:\n$authAdapter = new AuthAdapter(\n    $dbAdapter,\n    'users',\n    'username',\n    'password',\n    $passwordValidation\n);\n\n// Or configure the instance with setter methods:\n$authAdapter = new AuthAdapter($dbAdapter);\n\n$authAdapter\n    ->setTableName('users')\n    ->setIdentityColumn('username')\n    ->setCredentialColumn('password')\n    ->setCredentialValidatinCallback($passwordValidation);\n\n\n\nAt this point, the authentication adapter instance is ready to accept\nauthentication queries. In order to formulate an authentication query, the\ninput credential values are passed to the adapter prior to calling the\n\nauthenticate()\n method:\n\n\n// Set the input credential values (e.g., from a login form):\n$authAdapter\n    ->setIdentity('my_username')\n    ->setCredential('my_password');\n\n// Perform the authentication query, saving the result\n$result = $authAdapter->authenticate();\n\n\n\nIn addition to the availability of the \ngetIdentity()\n method upon the\nauthentication result object, \nZend\\Authentication\\Adapter\\DbTable\\CallbackCheckAdapter\n\nalso supports retrieving the table row upon authentication success:\n\n\n// Print the identity:\necho $result->getIdentity() . \"\\n\\n\";\n\n// Print the result row:\nprint_r($authAdapter->getResultRowObject());\n\n/* Output:\nmy_username\n\nArray\n(\n    [id] => 1\n    [username] => my_username\n    [password] => my_password\n    [real_name] => My Real Name\n)\n*/\n\n\n\nSince the table row contains the credential value, it is important to secure\nthe values against unintended access.\n\n\nWhen retrieving the result object, we can either specify what columns to\nreturn, or what columns to omit:\n\n\n// Specify the columns to return:\n$columnsToReturn = [\n    'id',\n    'username',\n    'real_name',\n];\nprint_r($authAdapter->getResultRowObject($columnsToReturn));\n\n/* Output:\n\nArray\n(\n   [id] => 1\n   [username] => my_username\n   [real_name] => My Real Name\n)\n*/\n\n// Or specify the columns to omit; when using this approach,\n// pass a null value as the first argument to getResultRowObject():\n$columnsToOmit = ['password'];\nprint_r($authAdapter->getResultRowObject(null, $columnsToOmit);\n\n/* Output:\n\nArray\n(\n   [id] => 1\n   [username] => my_username\n   [real_name] => My Real Name\n)\n*/\n\n\n\nAdvanced Usage\n\n\nWhile the basic use case will fit most scenarios, there may be cases where you have\nspecialized needs, such as additional criteria that needs to be met for a user to\nmatch.\n\n\nAdding criteria to match\n\n\nSince the validation callback is only provided the hash value from the database\nand the credential provided by the user, you cannot do more complex matching\nwithin it. However, you can add criteria to the SQL sent to the server by\nretrieving the \nZend\\Db\\Sql\\Select\n instance is uses.\n\n\nAs an example, many websites require a user to activate their account before\nallowing them to login for the first time. We can add that criteria as follows:\n\n\n// Create a basic adapter, with only an MD5() credential treatment:\n$adapter = new AuthAdapter(\n    $db,\n    'users',\n    'username',\n    'password',\n    $passwordValidation\n);\n\n// Now retrieve the Select instance and modify it:\n$select = $adapter->getDbSelect();\n$select->where('active = \"TRUE\"');\n\n// Authenticate; this will include \"users.active = TRUE\" in the WHERE clause:\n$adapter->authenticate();",
            "title": "CallbackCheck"
        },
        {
            "location": "/adapter/dbtable/callback-check/#callback-verification",
            "text": "Some verification operations cannot be performed well on RDBMS servers. Other\ntimes, you may be unsure which RDBMS system you will be using long-term, and\nneed to ensure authentication will work consistently. For these situations, you\ncan use the  Zend\\Authentication\\Adapter\\DbTable\\CallbackCheckAdapter  adapter.\nSimilar to the  CredentialTreatmentAdapter , it\naccepts a table name, identity column, and credential column; however, instead\nof a credential treatment, it accepts a  credential validation callback  that\nis executed when the database returns any matches, and which can be used to\nperform additional credential verifications.",
            "title": "Callback Verification"
        },
        {
            "location": "/adapter/dbtable/callback-check/#configuration-options",
            "text": "The available configuration options include:   tableName : This is the name of the database table that contains the\n  authentication credentials, and against which the database authentication\n  query is performed.  identityColumn : This is the name of the database table column used to\n  represent the identity.  The identity column must contain unique values, such\n  as a username or e-mail address.  credentialColumn : This is the name of the database table column used to\n  represent the credential. Under a simple identity and password authentication\n  scheme, the credential value corresponds to the password.  credentialValidationCallback : A PHP callable to execute when the database returns matches. The callback will receive:  the value of the  credentialColumn  returned from the database  the credential that was used by the adapter during authentication",
            "title": "Configuration options"
        },
        {
            "location": "/adapter/dbtable/callback-check/#basic-usage",
            "text": "Many databases do not provide functions that implement a cryptographically\nsecure hashing mechanism. Additionally, you may want to ensure that should you\nswitch database systems, hashing is consistent. This is a perfect use case for\nthe  CallbackCheckAdapter  adapter; you can implement the password hashing and\nverification within PHP instead.  The following code creates an adapter for an in-memory database, creates a\nsimple table schema, and inserts a row against which we can perform an\nauthentication query later. This example requires the PDO SQLite extension to\nbe available:  use Zend\\Db\\Adapter\\Adapter as DbAdapter;\n\n// Create a SQLite database connection\n$dbAdapter = new DbAdapter([\n    'driver'   => 'Pdo_Sqlite',\n    'database' => 'data/sqlite.db',\n]);\n\n// Build a simple table creation query\n$sqlCreate = 'CREATE TABLE [users] ('\n    . '[id] INTEGER  NOT NULL PRIMARY KEY, '\n    . '[username] VARCHAR(50) UNIQUE NOT NULL, '\n    . '[password] VARCHAR(255) NULL, '\n    . '[real_name] VARCHAR(150) NULL)';\n\n// Create the authentication credentials table\n$dbAdapter->query($sqlCreate);\n\n// Build a query to insert a row for which authentication may succeed\n$sqlInsert = \"INSERT INTO users (username, password, real_name) \"\n    . \"VALUES ('my_username', 'my_password', 'My Real Name')\";\n\n// Insert the data\n$dbAdapter->query($sqlInsert);  As you add users, you will need to create a hash of the password provided and\ninsert that into the database. For users on PHP 5.5+, you can use password_hash() :  $hash = password_hash($password, PASSWORD_DEFAULT);",
            "title": "Basic Usage"
        },
        {
            "location": "/adapter/dbtable/callback-check/#password-hash-length",
            "text": "As of the time of writing, PHP uses a bcrypt algorithm by default for hashing\npasswords with  password_hash() , and this produces 60 character strings. However,\nthe default may change over time, and php.net recommends using 255 character\nfields for storage to allow for larger hash sizes in the future.   To verify a password, we'll create a callback that uses password_verify() :  $passwordValidation = function ($hash, $password) {\n    return password_verify($password, $hash);\n};  Now that we have the database connection and a password validation function,\nwe can create our  Zend\\Authentication\\Adapter\\DbTable\\CallbackCheckAdapter  adapter\ninstance, passing the options to the constructor or later via setter methods:  use Zend\\Authentication\\Adapter\\DbTable\\CallbackCheckAdapter as AuthAdapter;\n\n// Configure the instance with constructor parameters:\n$authAdapter = new AuthAdapter(\n    $dbAdapter,\n    'users',\n    'username',\n    'password',\n    $passwordValidation\n);\n\n// Or configure the instance with setter methods:\n$authAdapter = new AuthAdapter($dbAdapter);\n\n$authAdapter\n    ->setTableName('users')\n    ->setIdentityColumn('username')\n    ->setCredentialColumn('password')\n    ->setCredentialValidatinCallback($passwordValidation);  At this point, the authentication adapter instance is ready to accept\nauthentication queries. In order to formulate an authentication query, the\ninput credential values are passed to the adapter prior to calling the authenticate()  method:  // Set the input credential values (e.g., from a login form):\n$authAdapter\n    ->setIdentity('my_username')\n    ->setCredential('my_password');\n\n// Perform the authentication query, saving the result\n$result = $authAdapter->authenticate();  In addition to the availability of the  getIdentity()  method upon the\nauthentication result object,  Zend\\Authentication\\Adapter\\DbTable\\CallbackCheckAdapter \nalso supports retrieving the table row upon authentication success:  // Print the identity:\necho $result->getIdentity() . \"\\n\\n\";\n\n// Print the result row:\nprint_r($authAdapter->getResultRowObject());\n\n/* Output:\nmy_username\n\nArray\n(\n    [id] => 1\n    [username] => my_username\n    [password] => my_password\n    [real_name] => My Real Name\n)\n*/  Since the table row contains the credential value, it is important to secure\nthe values against unintended access.  When retrieving the result object, we can either specify what columns to\nreturn, or what columns to omit:  // Specify the columns to return:\n$columnsToReturn = [\n    'id',\n    'username',\n    'real_name',\n];\nprint_r($authAdapter->getResultRowObject($columnsToReturn));\n\n/* Output:\n\nArray\n(\n   [id] => 1\n   [username] => my_username\n   [real_name] => My Real Name\n)\n*/\n\n// Or specify the columns to omit; when using this approach,\n// pass a null value as the first argument to getResultRowObject():\n$columnsToOmit = ['password'];\nprint_r($authAdapter->getResultRowObject(null, $columnsToOmit);\n\n/* Output:\n\nArray\n(\n   [id] => 1\n   [username] => my_username\n   [real_name] => My Real Name\n)\n*/",
            "title": "Password hash length"
        },
        {
            "location": "/adapter/dbtable/callback-check/#advanced-usage",
            "text": "While the basic use case will fit most scenarios, there may be cases where you have\nspecialized needs, such as additional criteria that needs to be met for a user to\nmatch.",
            "title": "Advanced Usage"
        },
        {
            "location": "/adapter/dbtable/callback-check/#adding-criteria-to-match",
            "text": "Since the validation callback is only provided the hash value from the database\nand the credential provided by the user, you cannot do more complex matching\nwithin it. However, you can add criteria to the SQL sent to the server by\nretrieving the  Zend\\Db\\Sql\\Select  instance is uses.  As an example, many websites require a user to activate their account before\nallowing them to login for the first time. We can add that criteria as follows:  // Create a basic adapter, with only an MD5() credential treatment:\n$adapter = new AuthAdapter(\n    $db,\n    'users',\n    'username',\n    'password',\n    $passwordValidation\n);\n\n// Now retrieve the Select instance and modify it:\n$select = $adapter->getDbSelect();\n$select->where('active = \"TRUE\"');\n\n// Authenticate; this will include \"users.active = TRUE\" in the WHERE clause:\n$adapter->authenticate();",
            "title": "Adding criteria to match"
        },
        {
            "location": "/adapter/digest/",
            "text": "Digest Authentication\n\n\nDigest authentication\n\nis a method of HTTP authentication that improves upon\n\nBasic authentication\n\nby providing a way to authenticate without having to transmit the password in\nclear text across the network.\n\n\nThis adapter allows authentication against text files containing lines having\nthe basic elements of Digest authentication:\n\n\n\n\nusername\n, such as \"joe.user\";\n\n\nrealm\n, such as \"Administrative Area\";\n\n\nan MD5 hash of the username, realm, and password, separated by colons.\n\n\n\n\nThe above elements are separated by colons, as in the following example (in\nwhich the password is \"somePassword\"):\n\n\nsomeUser:Some Realm:fde17b91c3a510ecbaf7dbd37f59d4f8\n\n\n\nSpecifics\n\n\nThe digest authentication adapter, \nZend\\Authentication\\Adapter\\Digest\n,\nrequires several input parameters:\n\n\n\n\nfilename\n: Filename against which authentication queries are performed.\n\n\nrealm\n: Digest authentication realm.\n\n\nusername\n: Digest authentication user.\n\n\npassword\n: Password for the user of the realm.\n\n\n\n\nThese parameters must be set prior to calling \nauthenticate()\n.\n\n\nIdentity\n\n\nThe digest authentication adapter returns a \nZend\\Authentication\\Result\n object\npopulated with the identity as an array containing the keys \nrealm\n and\n\nusername\n. The respective array values associated with these keys correspond\nto the values set before \nauthenticate()\n is called.\n\n\nuse Zend\\Authentication\\Adapter\\Digest as AuthAdapter;\n\n$adapter = new AuthAdapter(\n    $filename,\n    $realm,\n    $username,\n    $password\n);\n\n$result = $adapter->authenticate();\n$identity = $result->getIdentity();\nprint_r($identity);\n\n/*\nArray\n(\n    [realm] => Some Realm\n    [username] => someUser\n)\n*/",
            "title": "Digest"
        },
        {
            "location": "/adapter/digest/#digest-authentication",
            "text": "Digest authentication \nis a method of HTTP authentication that improves upon Basic authentication \nby providing a way to authenticate without having to transmit the password in\nclear text across the network.  This adapter allows authentication against text files containing lines having\nthe basic elements of Digest authentication:   username , such as \"joe.user\";  realm , such as \"Administrative Area\";  an MD5 hash of the username, realm, and password, separated by colons.   The above elements are separated by colons, as in the following example (in\nwhich the password is \"somePassword\"):  someUser:Some Realm:fde17b91c3a510ecbaf7dbd37f59d4f8",
            "title": "Digest Authentication"
        },
        {
            "location": "/adapter/digest/#specifics",
            "text": "The digest authentication adapter,  Zend\\Authentication\\Adapter\\Digest ,\nrequires several input parameters:   filename : Filename against which authentication queries are performed.  realm : Digest authentication realm.  username : Digest authentication user.  password : Password for the user of the realm.   These parameters must be set prior to calling  authenticate() .",
            "title": "Specifics"
        },
        {
            "location": "/adapter/digest/#identity",
            "text": "The digest authentication adapter returns a  Zend\\Authentication\\Result  object\npopulated with the identity as an array containing the keys  realm  and username . The respective array values associated with these keys correspond\nto the values set before  authenticate()  is called.  use Zend\\Authentication\\Adapter\\Digest as AuthAdapter;\n\n$adapter = new AuthAdapter(\n    $filename,\n    $realm,\n    $username,\n    $password\n);\n\n$result = $adapter->authenticate();\n$identity = $result->getIdentity();\nprint_r($identity);\n\n/*\nArray\n(\n    [realm] => Some Realm\n    [username] => someUser\n)\n*/",
            "title": "Identity"
        },
        {
            "location": "/adapter/http/",
            "text": "HTTP Authentication Adapter\n\n\nZend\\Authentication\\Adapter\\Http\n provides a mostly-compliant implementation of\n\nRFC-2617\n,\n\nBasic\n and\n\nDigest\n HTTP\nAuthentication. Digest authentication is a method of HTTP authentication that\nimproves upon Basic authentication by providing a way to authenticate without\nhaving to transmit the password in clear text across the network.\n\n\nMajor Features\n\n\n\n\nSupports both Basic and Digest authentication.\n\n\nIssues challenges in all supported schemes, so client can respond with any\n  scheme it supports.\n\n\nSupports proxy authentication.\n\n\nIncludes support for authenticating against text files and provides an\n  interface for authenticating against other sources, such as databases.\n\n\n\n\nThere are a few notable features of RFC-2617 that are not implemented yet:\n\n\n\n\nNonce tracking, which would allow for \"stale\" support, and increased replay\n  attack protection.\n\n\nAuthentication with integrity checking, or \"auth-int\".\n\n\nAuthentication-Info HTTP header.\n\n\n\n\nRequirements\n\n\nThe HTTP authentication adapter requires \nzend-http\n\nin order to do its work:\n\n\n$ composer require zendframework/zend-http\n\n\n\nDesign Overview\n\n\nThis adapter consists of two sub-components, the HTTP authentication class\nitself, and its \"Resolvers.\" The HTTP authentication class encapsulates the\nlogic for carrying out both Basic and Digest authentication. It consumes\nResolvers to look up a client's identity in some data store (text file by\ndefault), and retrieve the credentials from the data store. The \"resolved\"\ncredentials are then compared to the values submitted by the client to\ndetermine whether authentication is successful.\n\n\nConfiguration Options\n\n\nZend\\Authentication\\Adapter\\Http\n requires a configuration array passed to its\nconstructor. There are several configuration options available, and some are\nrequired:\n\n\n\n\n\n\n\n\nOption Name\n\n\nRequired\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\naccept_schemes\n\n\nYes\n\n\nDetermines which authentication schemes the adapter will accept from the client. Must be a space-separated list containing \nbasic\n and/or \ndigest\n.\n\n\n\n\n\n\nrealm\n\n\nYes\n\n\nSets the authentication realm; usernames should be unique within a given realm.\n\n\n\n\n\n\ndigest_domains\n\n\nYes, when \naccept_schemes\n contains digest\n\n\nSpace-separated list of URIs for which the same authentication information is valid. The URIs need not all point to the same server.\n\n\n\n\n\n\nnonce_timeout\n\n\nYes, when \naccept_schemes\n contains digest\n\n\nSets the number of seconds for which the nonce is valid. See notes below.\n\n\n\n\n\n\nuse_opaque\n\n\nNo\n\n\nSpecifies whether to send the opaque value in the header. True by default.\n\n\n\n\n\n\nalgorithm\n\n\nNo\n\n\nSpecified the algorithm. Defaults to MD5, the only supported option (for now).\n\n\n\n\n\n\nproxy_auth\n\n\nNo\n\n\nDisabled by default. Enable to perform Proxy authentication, instead of normal origin server authentication.\n\n\n\n\n\n\n\n\n\n\nnonce timeout\n\n\nThe current implementation of the \nnonce_timeout\n has some interesting side\neffects. This setting is supposed to determine the valid lifetime of a given\nnonce, or effectively how long a client's authentication information is\naccepted. As an example, if it's set to 3600, it will cause the adapter to\nprompt the client for new credentials every hour, on the hour.  This will be\nresolved in a future release, once nonce tracking and stale support are\nimplemented.\n\n\n\n\nResolvers\n\n\nA resolver's job is to take a username and realm, and return some kind of\ncredential value. Basic authentication expects to receive the base64-encoded\nversion of the user's password. Digest authentication expects to receive a hash\nof the user's username, the realm, and their password (each separated by\ncolons). Currently, the only supported hash algorithm is MD5.\n\n\nZend\\Authentication\\Adapter\\Http\n relies on objects implementing\n\nZend\\Authentication\\Adapter\\Http\\ResolverInterface\n. The component includes\nresolvers for plain text files and Apache \nhtpasswd\n-generated files; you can\nalso provide your own implementations.\n\n\nFile Resolver\n\n\nThe file resolver is a very simple class. It has a single property specifying a\nfilename, which can also be passed to the constructor. Its \nresolve()\n method\nwalks through the text file, searching for a line with a matching username and\nrealm. The text file format is similar to Apache \nhtpasswd\n files:\n\n\n<username>:<realm>:<credentials>\n\n\n\nEach line consists of three fields \u2014 username, realm, and credentials\n\u2014 each separated by a colon.  The credentials field is opaque to the file\nresolver; it simply returns that value as-is to the caller. Therefore, this\nsame file format serves both Basic and Digest authentication. In Basic\nauthentication, the credentials field should be written in clear text. In\nDigest authentication, it should be the MD5 hash described above.\n\n\nThere are two ways to create a file resolver:\n\n\nuse Zend\\Authentication\\Adapter\\Http\\FileResolver;\n\n$path     = 'data/passwd.txt';\n$resolver = new FileResolver($path);\n\n\n\nor\n\n\n$path     = 'data/passwd.txt';\n$resolver = new FileResolver();\n$resolver->setFile($path);\n\n\n\nIf the given path is empty or not readable, an exception is thrown.\n\n\nApache Resolver\n\n\nZend\\Authentication\\Adapter\\Http\\ApacheResolver\n operates similarly to the\n\nFileResolver\n, but is capable of reading files generated by Apache's \nhtpasswd\n\nfacility, as described in the \nApache documentation\n.\n\n\nIn order to do so, you will need to also install \nzend-crypt\n:\n\n\n$ composer require zendframework/zend-crypt\n\n\n\nIn all other ways, it behaves like the \nFileResolver\n, meaning you instantiate\nit with a path to the \nhtpasswd\n-generated file, or inject the path after\ninstantiation:\n\n\nuse Zend\\Authentication\\Adapter\\Http\\ApacheResolver;\n\n$path = 'data/htpasswd';\n\n// Inject at instantiation:\n$resolver = new ApacheResolver($path);\n\n// Or afterwards:\n$resolver = new ApacheResolver();\n$resolver->setFile($path);\n\n\n\nBasic Usage\n\n\nFirst, set up an array with the required configuration values:\n\n\n$config = [\n    'accept_schemes' => 'basic digest',\n    'realm'          => 'My Web Site',\n    'digest_domains' => '/members_only /my_account',\n    'nonce_timeout'  => 3600,\n];\n\n\n\nThis array will cause the adapter to accept either Basic or Digest\nauthentication, and will require authenticated access to all the areas of the\nsite under \n/members_only\n and \n/my_account\n. The realm value is usually\ndisplayed by the browser in the password dialog box. The \nnonce_timeout\n\nbehaves as described above.\n\n\nNext, create the \nZend\\Authentication\\Adapter\\Http\n object:\n\n\nuse Zend\\Authentication\\Adapter\\Http;\n\n$adapter = new Http($config);\n\n\n\nSince we're supporting both Basic and Digest authentication, we need two\ndifferent resolver objects.\n\n\nuse Zend\\Authentication\\Adapter\\Http\\FileResolver;\n\n$basicResolver  = new FileResolver('data/basic-passwd.txt');\n$digestResolver = new FileResolver('data/digest-passwd.txt');\n\n$adapter->setBasicResolver($basicResolver);\n$adapter->setDigestResolver($digestResolver);\n\n\n\nFinally, we perform authentication. The adapter requires zend-http request and\nresponse instances in order to lookup credentials and provide challenge responses:\n\n\nuse Zend\\Http\\Request;\nuse Zend\\Http\\Response;\n\n// $request is an instance of Request\n// $response is an instance of Response\n$adapter->setRequest($request);\n$adapter->setResponse($response);\n\n$result = $adapter->authenticate();\nif (! $result->isValid()) {\n    // Bad username/password, or canceled password prompt\n}",
            "title": "HTTP"
        },
        {
            "location": "/adapter/http/#http-authentication-adapter",
            "text": "Zend\\Authentication\\Adapter\\Http  provides a mostly-compliant implementation of RFC-2617 , Basic  and Digest  HTTP\nAuthentication. Digest authentication is a method of HTTP authentication that\nimproves upon Basic authentication by providing a way to authenticate without\nhaving to transmit the password in clear text across the network.",
            "title": "HTTP Authentication Adapter"
        },
        {
            "location": "/adapter/http/#major-features",
            "text": "Supports both Basic and Digest authentication.  Issues challenges in all supported schemes, so client can respond with any\n  scheme it supports.  Supports proxy authentication.  Includes support for authenticating against text files and provides an\n  interface for authenticating against other sources, such as databases.   There are a few notable features of RFC-2617 that are not implemented yet:   Nonce tracking, which would allow for \"stale\" support, and increased replay\n  attack protection.  Authentication with integrity checking, or \"auth-int\".  Authentication-Info HTTP header.",
            "title": "Major Features"
        },
        {
            "location": "/adapter/http/#requirements",
            "text": "The HTTP authentication adapter requires  zend-http \nin order to do its work:  $ composer require zendframework/zend-http",
            "title": "Requirements"
        },
        {
            "location": "/adapter/http/#design-overview",
            "text": "This adapter consists of two sub-components, the HTTP authentication class\nitself, and its \"Resolvers.\" The HTTP authentication class encapsulates the\nlogic for carrying out both Basic and Digest authentication. It consumes\nResolvers to look up a client's identity in some data store (text file by\ndefault), and retrieve the credentials from the data store. The \"resolved\"\ncredentials are then compared to the values submitted by the client to\ndetermine whether authentication is successful.",
            "title": "Design Overview"
        },
        {
            "location": "/adapter/http/#configuration-options",
            "text": "Zend\\Authentication\\Adapter\\Http  requires a configuration array passed to its\nconstructor. There are several configuration options available, and some are\nrequired:     Option Name  Required  Description      accept_schemes  Yes  Determines which authentication schemes the adapter will accept from the client. Must be a space-separated list containing  basic  and/or  digest .    realm  Yes  Sets the authentication realm; usernames should be unique within a given realm.    digest_domains  Yes, when  accept_schemes  contains digest  Space-separated list of URIs for which the same authentication information is valid. The URIs need not all point to the same server.    nonce_timeout  Yes, when  accept_schemes  contains digest  Sets the number of seconds for which the nonce is valid. See notes below.    use_opaque  No  Specifies whether to send the opaque value in the header. True by default.    algorithm  No  Specified the algorithm. Defaults to MD5, the only supported option (for now).    proxy_auth  No  Disabled by default. Enable to perform Proxy authentication, instead of normal origin server authentication.",
            "title": "Configuration Options"
        },
        {
            "location": "/adapter/http/#nonce-timeout",
            "text": "The current implementation of the  nonce_timeout  has some interesting side\neffects. This setting is supposed to determine the valid lifetime of a given\nnonce, or effectively how long a client's authentication information is\naccepted. As an example, if it's set to 3600, it will cause the adapter to\nprompt the client for new credentials every hour, on the hour.  This will be\nresolved in a future release, once nonce tracking and stale support are\nimplemented.",
            "title": "nonce timeout"
        },
        {
            "location": "/adapter/http/#resolvers",
            "text": "A resolver's job is to take a username and realm, and return some kind of\ncredential value. Basic authentication expects to receive the base64-encoded\nversion of the user's password. Digest authentication expects to receive a hash\nof the user's username, the realm, and their password (each separated by\ncolons). Currently, the only supported hash algorithm is MD5.  Zend\\Authentication\\Adapter\\Http  relies on objects implementing Zend\\Authentication\\Adapter\\Http\\ResolverInterface . The component includes\nresolvers for plain text files and Apache  htpasswd -generated files; you can\nalso provide your own implementations.",
            "title": "Resolvers"
        },
        {
            "location": "/adapter/http/#file-resolver",
            "text": "The file resolver is a very simple class. It has a single property specifying a\nfilename, which can also be passed to the constructor. Its  resolve()  method\nwalks through the text file, searching for a line with a matching username and\nrealm. The text file format is similar to Apache  htpasswd  files:  <username>:<realm>:<credentials>  Each line consists of three fields \u2014 username, realm, and credentials\n\u2014 each separated by a colon.  The credentials field is opaque to the file\nresolver; it simply returns that value as-is to the caller. Therefore, this\nsame file format serves both Basic and Digest authentication. In Basic\nauthentication, the credentials field should be written in clear text. In\nDigest authentication, it should be the MD5 hash described above.  There are two ways to create a file resolver:  use Zend\\Authentication\\Adapter\\Http\\FileResolver;\n\n$path     = 'data/passwd.txt';\n$resolver = new FileResolver($path);  or  $path     = 'data/passwd.txt';\n$resolver = new FileResolver();\n$resolver->setFile($path);  If the given path is empty or not readable, an exception is thrown.",
            "title": "File Resolver"
        },
        {
            "location": "/adapter/http/#apache-resolver",
            "text": "Zend\\Authentication\\Adapter\\Http\\ApacheResolver  operates similarly to the FileResolver , but is capable of reading files generated by Apache's  htpasswd \nfacility, as described in the  Apache documentation .  In order to do so, you will need to also install  zend-crypt :  $ composer require zendframework/zend-crypt  In all other ways, it behaves like the  FileResolver , meaning you instantiate\nit with a path to the  htpasswd -generated file, or inject the path after\ninstantiation:  use Zend\\Authentication\\Adapter\\Http\\ApacheResolver;\n\n$path = 'data/htpasswd';\n\n// Inject at instantiation:\n$resolver = new ApacheResolver($path);\n\n// Or afterwards:\n$resolver = new ApacheResolver();\n$resolver->setFile($path);",
            "title": "Apache Resolver"
        },
        {
            "location": "/adapter/http/#basic-usage",
            "text": "First, set up an array with the required configuration values:  $config = [\n    'accept_schemes' => 'basic digest',\n    'realm'          => 'My Web Site',\n    'digest_domains' => '/members_only /my_account',\n    'nonce_timeout'  => 3600,\n];  This array will cause the adapter to accept either Basic or Digest\nauthentication, and will require authenticated access to all the areas of the\nsite under  /members_only  and  /my_account . The realm value is usually\ndisplayed by the browser in the password dialog box. The  nonce_timeout \nbehaves as described above.  Next, create the  Zend\\Authentication\\Adapter\\Http  object:  use Zend\\Authentication\\Adapter\\Http;\n\n$adapter = new Http($config);  Since we're supporting both Basic and Digest authentication, we need two\ndifferent resolver objects.  use Zend\\Authentication\\Adapter\\Http\\FileResolver;\n\n$basicResolver  = new FileResolver('data/basic-passwd.txt');\n$digestResolver = new FileResolver('data/digest-passwd.txt');\n\n$adapter->setBasicResolver($basicResolver);\n$adapter->setDigestResolver($digestResolver);  Finally, we perform authentication. The adapter requires zend-http request and\nresponse instances in order to lookup credentials and provide challenge responses:  use Zend\\Http\\Request;\nuse Zend\\Http\\Response;\n\n// $request is an instance of Request\n// $response is an instance of Response\n$adapter->setRequest($request);\n$adapter->setResponse($response);\n\n$result = $adapter->authenticate();\nif (! $result->isValid()) {\n    // Bad username/password, or canceled password prompt\n}",
            "title": "Basic Usage"
        },
        {
            "location": "/adapter/ldap/",
            "text": "LDAP Authentication\n\n\nZend\\Authentication\\Adapter\\Ldap\n supports web application authentication with\nLDAP services. Its features include username and domain name canonicalization,\nmulti-domain authentication, and failover capabilities. It has been tested to\nwork with \nMicrosoft Active Directory\n\nand \nOpenLDAP\n, but it should also work with other\nLDAP service providers.\n\n\nThis documentation includes a guide on using \nZend\\Authentication\\Adapter\\Ldap\n,\nan exploration of its API, an outline of the various available options,\ndiagnostic information for troubleshooting authentication problems, and example\noptions for both Active Directory and OpenLDAP servers.\n\n\nUsage\n\n\nThe following example demonstrates creating and configuring the \nLdap\n\nauthentication adapter, and also illustrates how to work with the\nauthentication messages returned in the authentication result.\n\n\nuse Zend\\Authentication\\AuthenticationService;\nuse Zend\\Authentication\\Adapter\\Ldap as LdapAdapter;\n\n// Retrieve the username and pasword from the request somehow.\n$username = /* ... */;\n$password = /* ... */;\n\n$auth = new AuthenticationService();\n\n$config = [\n    'server1' => [\n        'host'                   => 's0.foo.net',\n        'accountDomainName'      => 'foo.net',\n        'accountDomainNameShort' => 'FOO',\n        'accountCanonicalForm'   => 3,\n        'username'               => 'CN=user1,DC=foo,DC=net',\n        'password'               => 'pass1',\n        'baseDn'                 => 'OU=Sales,DC=foo,DC=net',\n        'bindRequiresDn'         => true,\n    ],\n    'server2' => [\n        'host'                   => 'dc1.w.net',\n        'useStartTls'            => true,\n        'accountDomainName'      => 'w.net',\n        'accountDomainNameShort' => 'W',\n        'accountCanonicalForm'   => 3,\n        'baseDn'                 => 'CN=Users,DC=w,DC=net',\n    ],\n];\n\n$adapter = new LdapAdapter($config, $username, $password);\n\n$result = $auth->authenticate($adapter);\n\n// Messages from position 2 and up are informational messages from the LDAP\n// server:\nforeach ($result->getMessages() as $i => $message) {\n    if ($i < 2) {\n        continue;\n    }\n\n    // Potentially log the $message\n}\n\n\n\nAs noted in the above example, the returned authentication result contains\nmessages even on success.  LDAP has some notoriety for difficulty in debugging,\nand the \nLdap\n adapter attempts to assist you with this by providing\ninformational messages for every authentication attempt. A later section in\nthis document provides more detail on the messages returned.\n\n\nYou will note that the configuration contains information for multiple servers.\nWhen multiple server configuration is provided, the adapter will loop through\neach until one provides successful authentication.  The above configuration\nwill instruct the adapter to attempt authenticattion against the OpenLDAP\nserver \ns0.foo.net\n first, falling back to the Active Directory server\n\ndc1.w.net\non failure.\n\n\nWith servers in different domains, this configuration illustrates multi-domain\nauthentication. You can also have multiple servers in the same domain to\nprovide redundancy.\n\n\nNote that in this case, even though OpenLDAP has no need for the short NetBIOS\nstyle domain name used by Windows, we provide it here for name canonicalization\npurposes (described in the \nUsername Canonicalization\n\nsection below).\n\n\nA later section on \nserver options\n details all available options)\n\n\nThe API\n\n\nThe \nZend\\Authentication\\Adapter\\Ldap\n constructor accepts three parameters.\n\n\nThe \n$options\n parameter is required and must be an array containing one or\nmore sets of options.  Note that it is \nan array of arrays\n, with each\nsub-array providing \nzend-ldap\n\noptions. Even if you will be using only one LDAP server, the options must still\nbe within a sub-array.\n\n\nReferring back to the example in the previous section, the information provided\nin each set of options is different mainly because Active Directory does not\nrequire a username be in DN form when binding (see the \nbindRequiresDn\n option\nin the \nServer Options\n section below), which means we can\nomit a number of options associated with retrieving the DN for a username being\nauthenticated.\n\n\n\n\nWhat is a Distinguished Name?\n\n\nA DN or \"distinguished name\" is a string that represents the path to an\nobject within the LDAP directory. Each comma-separated component is an\nattribute and value representing a node. The components are evaluated in\nreverse. For example, the user account \nCN=Bob Carter,CN=Users,DC=w,DC=net\n\nis located directly within the \nCN=Users,DC=w,DC=net container\n.  This\nstructure is best explored with an LDAP browser like the ADSI Edit MMC\nsnap-in for Active Directory or phpLDAPadmin.\n\n\n\n\nThe names of servers (e.g. 'server1' and 'server2' shown above) are largely\narbitrary and only used for informational purposes by the adapter. We recommend\nusing string identifiers that omit any HTML/XML entity references to ensure\nthey do not break any logging displays.\n\n\nWith multiple sets of server options, the adapter can authenticate users in\nmultiple domains and provide failover so that if one server is not available,\nanother will be queried.\n\n\n\n\nThe Gory Details: What Happens in the Authenticate Method?\n\n\nWhen the \nauthenticate()\n method is called, the adapter iterates over each\nset of server options, passes them to the internal \nZend\\Ldap\\Ldap\n instance,\nand calls the \nZend\\Ldap\\Ldap::bind()\n method with the username and password\nbeing authenticated.\n\n\nZend\\Ldap\\Ldap\n checks to see if the username is qualified with a domain\n(e.g., has a domain component like \nalice@foo.net\n or \nFOO\\alice\n). If a\ndomain is present, but does not match either of the server's domain names\n(e.g., \nfoo.net\n or \nFOO\n), a special exception is thrown and caught by\n\nZend\\Authentication\\Adapter\\Ldap\n that causes that server to be ignored, and\nprogression to the next server configured.\n\n\nIf a domain matches, or if the user did not supply a qualified username,\n\nZend\\Ldap\\Ldap\n proceeds to try to bind with the supplied credentials. if\nthe bind is unsuccessful, \nZend\\Ldap\\Ldap\n throws a\n\nZend\\Ldap\\Exception\\LdapException\n which is caught by\n\nZend\\Authentication\\Adapter\\Ldap\n and, again, the adapter progresses to the\nnext configured server.\n\n\nIf the bind is successful, server iteration stops, and the adapter's\n\nauthenticate()\n method returns a successful result.\n\n\nIf all configured servers fail to authenticate, \nauthenticate()\n returns a\nfailure result with error messages from the last server consulted.\n\n\n\n\nThe username and password parameters of the \nZend\\Authentication\\Adapter\\Ldap\n\nconstructor represent the credentials being authenticated (i.e., the\ncredentials supplied by the user through your HTML login form). Alternatively,\nthey may also be set with the \nsetUsername()\n and \nsetPassword()\n methods.\n\n\nServer Options\n\n\nEach set of server options in the context of \nZend\\Authentication\\Adapter\\Ldap\n\nconsists of the following options, which are passed, largely unmodified, to\n\nZend\\Ldap\\Ldap::setOptions()\n:\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nhost\n\n\nThe hostname of LDAP server that these options represent. This option is required.\n\n\n\n\n\n\nport\n\n\nThe port on which the LDAP server is listening. If \nuseSsl\n is \nTRUE\n, the default port value is 636. If \nuseSsl\n is \nFALSE\n, the default port value is 389.\n\n\n\n\n\n\nuseStartTls\n\n\nWhether or not the LDAP client should use TLS (aka SSLv2) encrypted transport. A value of \nTRUE\n is strongly favored in production environments to prevent passwords from be transmitted in clear text. The default value is \nFALSE\n, as servers frequently require that a certificate be installed separately after installation. The \nuseSsl\n and \nuseStartTls\n options are mutually exclusive. The \nuseStartTls\n option should be favored over \nuseSsl\n, but not all servers support this newer mechanism.\n\n\n\n\n\n\nuseSsl\n\n\nWhether or not the LDAP client should use SSL encrypted transport. The \nuseSsl\n and \nuseStartTls\n options are mutually exclusive, but \nuseStartTls\n should be favored if the server and LDAP client library support it. This value also changes the default port value (see port description above).\n\n\n\n\n\n\nusername\n\n\nThe DN of the account used to perform account DN lookups. LDAP servers that require the username to be in DN form when performing the \u201cbind\u201d require this option. Meaning, if \nbindRequiresDn\n is \nTRUE\n, this option is required. This account does not need to be a privileged account; an account with read-only access to objects under the \nbaseDn\n is all that is necessary (and preferred based on the Principle of Least Privilege).\n\n\n\n\n\n\npassword\n\n\nThe password of the account used to perform account DN lookups. If this option is not supplied, the LDAP client will attempt an \u201canonymous bind\u201d when performing account DN lookups.\n\n\n\n\n\n\nbindRequiresDn\n\n\nSome LDAP servers require that the username used to bind be in DN form like \nCN=Alice Baker,OU=Sales,DC=foo,DC=net\n (basically all servers except Active Directory). If this option is \nTRUE\n, this instructs \nZend\\Ldap\\Ldap\n to automatically retrieve the DN corresponding to the username being authenticated, if it is not already in DN form, and then re-bind with the proper DN. The default value is \nFALSE\n. Currently only Microsoft Active Directory Server (ADS) is known not to require usernames to be in DN form when binding, and therefore this option may be \nFALSE\n with AD (and it should be, as retrieving the DN requires an extra round trip to the server). Otherwise, this option must be set to \nTRUE\n (e.g. for OpenLDAP). This option also controls the default \naccountFilterFormat\n used when searching for accounts. See the \naccountFilterFormat\n option.\n\n\n\n\n\n\nbaseDn\n\n\nThe DN under which all accounts being authenticated are located. This option is required. if you are uncertain about the correct baseDn value, it should be sufficient to derive it from the user\u2019s DNS domain using \nDC=\n components. For example, if the user\u2019s principal name is \nalice@foo.net\n, a \nbaseDn\n of \nDC=foo,DC=net\n should work. A more precise location (e.g., \nOU=Sales,DC=foo,DC=net\n) will be more efficient, however.\n\n\n\n\n\n\naccountCanonicalForm\n\n\nA value of 2, 3, or 4 indicating the form to which account names should be canonicalized after successful authentication. Values are as follows: 2 for traditional username style names (e.g., \nalice\n), 3 for backslash-style names (e.g., \nFOO\\alice\n) or 4 for principal style usernames (e.g., \nalice@foo.net\n). The default value is 4 (e.g., \nalice@foo.net\n). For example, with a value of 3, the identity returned by \nZend\\Authentication\\Result::getIdentity()\n (and \nZend\\Authentication\\AuthenticationService::getIdentity()\n, if \nZend\\Authentication\\AuthenticationService\n was used) will always be \nFOO\\alice\n, regardless of what form Alice supplied, whether it be \nalice\n, \nalice@foo.net\n, \nFOO\\alice\n, \nFoO\\aLicE\n, \nfoo.net\\alice\n, etc. See the \nAccount Name Canonicalization\n section in the zend-ldap documentation for details. Note that when using multiple sets of server options it is recommended, but not required, that the same \naccountCanonicalForm\n be used with all server options so that the resulting usernames are always canonicalized to the same form (e.g., if you canonicalize to \nEXAMPLE\\username\n with an AD server but to \nusername@example.com\n with an OpenLDAP server, that may be awkward for the application\u2019s high-level logic).\n\n\n\n\n\n\naccountDomainName\n\n\nThe FQDN domain name for which the target LDAP server is an authority (e.g., \nexample.com\n). This option is used to canonicalize names so that the username supplied by the user can be converted as necessary for binding. It is also used to determine if the server is an authority for the supplied username (e.g., if \naccountDomainName\n is \nfoo.net\n and the user supplies \nbob@bar.net\n, the server will not be queried, and a failure will result). This option is not required, but if it is not supplied, usernames in principal name form (e.g., \nalice@foo.net\n) are not supported. It is strongly recommended that you supply this option, as there are many use-cases that require generating the principal name form.\n\n\n\n\n\n\naccountDomainNameShort\n\n\nThe \u2018short\u2019 domain for which the target LDAP server is an authority (e.g., \nFOO\n). Note that there is a 1:1 mapping between the \naccountDomainName\n and \naccountDomainNameShort\n. This option should be used to specify the NetBIOS domain name for Windows networks, but may also be used by non-AD servers (e.g., for consistency when multiple sets of server options with the backslash style \naccountCanonicalForm\n). This option is not required but if it is not supplied, usernames in backslash form (e.g., \nFOO\\alice\n) are not supported.\n\n\n\n\n\n\naccountFilterFormat\n\n\nThe LDAP search filter used to search for accounts. This string is a \nprintf()\n-style expression that must contain one \n%s\n to accommodate the username. The default value is \n(&(objectClass=user)(sAMAccountName=%s))\n, unless \nbindRequiresDn\n is set to \nTRUE\n, in which case the default is \n(&(objectClass=posixAccount)(uid=%s))\n. For example, if for some reason you wanted to use \nbindRequiresDn = true\n with AD you would need to set \naccountFilterFormat = '(&(objectClass=user)(sAMAccountName=%s))'\n.\n\n\n\n\n\n\noptReferrals\n\n\nIf set to \nTRUE\n, this option indicates to the LDAP client that referrals should be followed. The default value is \nFALSE\n.\n\n\n\n\n\n\n\n\n\n\nTLS and SSL\n\n\nIf you enable \nuseStartTls = TRUE\n or \nuseSsl = TRUE\n you may find that the\nLDAP client generates an error claiming that it cannot validate the server's\ncertificate. Assuming the PHP LDAP extension is ultimately linked to the\nOpenLDAP client libraries, to resolve this issue you can set \nTLS_REQCERT\nnever\n in the OpenLDAP client \nldap.conf\n (and restart the web server) to\nindicate to the OpenLDAP client library that you trust the server.\nAlternately, if you are concerned that the server could be spoofed, you can\nexport the LDAP server's root certificate and put it on the web server so\nthat the OpenLDAP client can validate the server's identity.\n\n\n\n\nCollecting Debugging Messages\n\n\nZend\\Authentication\\Adapter\\Ldap\n collects debugging information within its\n\nauthenticate()\n method. This information is stored in the\n\nZend\\Authentication\\Result\n object as messages. The array returned by\n\nZend\\Authentication\\Result::getMessages()\n is described as follows:\n\n\n\n\n\n\n\n\nMessages Array Index\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nIndex 0\n\n\nA generic, user-friendly message that is suitable for displaying to users (e.g., \"Invalid credentials\"). If the authentication is successful, this string is empty.\n\n\n\n\n\n\nIndex 1\n\n\nA more detailed error message that is not suitable to be displayed to users but should be logged for the benefit of server operators. If the authentication is successful, this string is empty.\n\n\n\n\n\n\nIndexes 2 and higher\n\n\nAll log messages in order starting at index 2.\n\n\n\n\n\n\n\n\nIn practice, index 0 should be displayed to the user (e.g., using the\n\nFlashMessenger helper\n),\nindex 1 should be logged and, if debugging information is being collected,\nindexes 2 and higher could be logged as well (although the final message always\nincludes the string from index 1).\n\n\nCommon Options for Specific Servers\n\n\nOptions for Active Directory\n\n\nFor AD*, the following options are noteworthy:\n\n\n\n\n\n\n\n\nName\n\n\nAdditional Notes\n\n\n\n\n\n\n\n\n\n\nhost\n\n\nAs with all servers, this option is required.\n\n\n\n\n\n\nuseStartTls\n\n\nFor the sake of security, this should be \nTRUE\n if the server has the necessary certificate installed.\n\n\n\n\n\n\nuseSsl\n\n\nPossibly used as an alternative to \nuseStartTls\n (see above).\n\n\n\n\n\n\nbaseDn\n\n\nAs with all servers, this option is required. By default, AD places all user accounts under the Users container (e.g., \nCN=Users,DC=foo,DC=net\n), but the default is not common in larger organizations. Ask your AD administrator what the best DN for accounts for your application would be.\n\n\n\n\n\n\naccountCanonicalForm\n\n\nYou almost certainly want this to be 3 for backslash style names (e.g., \nFOO\\alice\n), which are most familiar to Windows users. You should not use the unqualified form 2 (e.g., \nalice\n), as this may grant access to your application to users with the same username in other trusted domains (e.g., \nBAR\\alice\n and \nFOO\\alice\n will be treated as the same user). (See also note below.)\n\n\n\n\n\n\naccountDomainName\n\n\nThis is required with AD unless \naccountCanonicalForm\n 2 is used, which, again, is discouraged.\n\n\n\n\n\n\naccountDomainNameShort\n\n\nThe NetBIOS name of the domain that users are in and for which the AD server is an authority. This is required if the backslash style \naccountCanonicalForm\n is used.\n\n\n\n\n\n\n\n\n\n\nUse qualified account names\n\n\nTechnically there should be no danger of accidental cross-domain\nauthentication with the current \nZend\\Authentication\\Adapter\\Ldap\n\nimplementation, since server domains are explicitly checked, but this may not\nbe true of a future implementation that discovers the domain at runtime, or\nif an alternative adapter is used (e.g., Kerberos). In general, account name\nambiguity is known to be the source of security issues, so always try to use\nqualified account names.\n\n\n\n\nOptions for OpenLDAP\n\n\nFor OpenLDAP or a generic LDAP server using a typical posixAccount style\nschema, the following options are noteworthy:\n\n\n\n\n\n\n\n\nName\n\n\nAdditional Notes\n\n\n\n\n\n\n\n\n\n\nhost\n\n\nAs with all servers, this option is required.\n\n\n\n\n\n\nuseStartTls\n\n\nFor the sake of security, this should be \nTRUE\n if the server has the necessary certificate installed.\n\n\n\n\n\n\nuseSsl\n\n\nPossibly used as an alternative to \nuseStartTls\n (see above).\n\n\n\n\n\n\nusername\n\n\nRequired and must be a DN, as OpenLDAP requires that usernames be in DN form when performing a bind. Try to use an unprivileged account.\n\n\n\n\n\n\npassword\n\n\nThe password corresponding to the username above, but this may be omitted if the LDAP server permits an anonymous binding to query user accounts.\n\n\n\n\n\n\nbindRequiresDn\n\n\nRequired and must be TRUE, as OpenLDAP requires that usernames be in DN form when performing a bind.\n\n\n\n\n\n\nbaseDn\n\n\nAs with all servers, this option is required and indicates the DN under which all accounts being authenticated are located.\n\n\n\n\n\n\naccountCanonicalForm\n\n\nOptional, but the default value is 4 (principal style names like \nalice@foo.net\n), which may not be ideal if your users are used to backslash style names (e.g., \nFOO\\alice\n). For backslash style names, use value 3.\n\n\n\n\n\n\naccountDomainName\n\n\nRequired unless you're using \naccountCanonicalForm\n 2, which is not recommended.\n\n\n\n\n\n\naccountDomainNameShort\n\n\nIf AD is not also being used, this value is not required. Otherwise, if \naccountCanonicalForm\n 3 is used, this option is required and should be a short name that corresponds adequately to the \naccountDomainName\n (e.g., if your \naccountDomainName\n is \nfoo.net\n, a good \naccountDomainNameShort\n value might be \nFOO\n).",
            "title": "LDAP"
        },
        {
            "location": "/adapter/ldap/#ldap-authentication",
            "text": "Zend\\Authentication\\Adapter\\Ldap  supports web application authentication with\nLDAP services. Its features include username and domain name canonicalization,\nmulti-domain authentication, and failover capabilities. It has been tested to\nwork with  Microsoft Active Directory \nand  OpenLDAP , but it should also work with other\nLDAP service providers.  This documentation includes a guide on using  Zend\\Authentication\\Adapter\\Ldap ,\nan exploration of its API, an outline of the various available options,\ndiagnostic information for troubleshooting authentication problems, and example\noptions for both Active Directory and OpenLDAP servers.",
            "title": "LDAP Authentication"
        },
        {
            "location": "/adapter/ldap/#usage",
            "text": "The following example demonstrates creating and configuring the  Ldap \nauthentication adapter, and also illustrates how to work with the\nauthentication messages returned in the authentication result.  use Zend\\Authentication\\AuthenticationService;\nuse Zend\\Authentication\\Adapter\\Ldap as LdapAdapter;\n\n// Retrieve the username and pasword from the request somehow.\n$username = /* ... */;\n$password = /* ... */;\n\n$auth = new AuthenticationService();\n\n$config = [\n    'server1' => [\n        'host'                   => 's0.foo.net',\n        'accountDomainName'      => 'foo.net',\n        'accountDomainNameShort' => 'FOO',\n        'accountCanonicalForm'   => 3,\n        'username'               => 'CN=user1,DC=foo,DC=net',\n        'password'               => 'pass1',\n        'baseDn'                 => 'OU=Sales,DC=foo,DC=net',\n        'bindRequiresDn'         => true,\n    ],\n    'server2' => [\n        'host'                   => 'dc1.w.net',\n        'useStartTls'            => true,\n        'accountDomainName'      => 'w.net',\n        'accountDomainNameShort' => 'W',\n        'accountCanonicalForm'   => 3,\n        'baseDn'                 => 'CN=Users,DC=w,DC=net',\n    ],\n];\n\n$adapter = new LdapAdapter($config, $username, $password);\n\n$result = $auth->authenticate($adapter);\n\n// Messages from position 2 and up are informational messages from the LDAP\n// server:\nforeach ($result->getMessages() as $i => $message) {\n    if ($i < 2) {\n        continue;\n    }\n\n    // Potentially log the $message\n}  As noted in the above example, the returned authentication result contains\nmessages even on success.  LDAP has some notoriety for difficulty in debugging,\nand the  Ldap  adapter attempts to assist you with this by providing\ninformational messages for every authentication attempt. A later section in\nthis document provides more detail on the messages returned.  You will note that the configuration contains information for multiple servers.\nWhen multiple server configuration is provided, the adapter will loop through\neach until one provides successful authentication.  The above configuration\nwill instruct the adapter to attempt authenticattion against the OpenLDAP\nserver  s0.foo.net  first, falling back to the Active Directory server dc1.w.net on failure.  With servers in different domains, this configuration illustrates multi-domain\nauthentication. You can also have multiple servers in the same domain to\nprovide redundancy.  Note that in this case, even though OpenLDAP has no need for the short NetBIOS\nstyle domain name used by Windows, we provide it here for name canonicalization\npurposes (described in the  Username Canonicalization \nsection below).  A later section on  server options  details all available options)",
            "title": "Usage"
        },
        {
            "location": "/adapter/ldap/#the-api",
            "text": "The  Zend\\Authentication\\Adapter\\Ldap  constructor accepts three parameters.  The  $options  parameter is required and must be an array containing one or\nmore sets of options.  Note that it is  an array of arrays , with each\nsub-array providing  zend-ldap \noptions. Even if you will be using only one LDAP server, the options must still\nbe within a sub-array.  Referring back to the example in the previous section, the information provided\nin each set of options is different mainly because Active Directory does not\nrequire a username be in DN form when binding (see the  bindRequiresDn  option\nin the  Server Options  section below), which means we can\nomit a number of options associated with retrieving the DN for a username being\nauthenticated.",
            "title": "The API"
        },
        {
            "location": "/adapter/ldap/#what-is-a-distinguished-name",
            "text": "A DN or \"distinguished name\" is a string that represents the path to an\nobject within the LDAP directory. Each comma-separated component is an\nattribute and value representing a node. The components are evaluated in\nreverse. For example, the user account  CN=Bob Carter,CN=Users,DC=w,DC=net \nis located directly within the  CN=Users,DC=w,DC=net container .  This\nstructure is best explored with an LDAP browser like the ADSI Edit MMC\nsnap-in for Active Directory or phpLDAPadmin.   The names of servers (e.g. 'server1' and 'server2' shown above) are largely\narbitrary and only used for informational purposes by the adapter. We recommend\nusing string identifiers that omit any HTML/XML entity references to ensure\nthey do not break any logging displays.  With multiple sets of server options, the adapter can authenticate users in\nmultiple domains and provide failover so that if one server is not available,\nanother will be queried.",
            "title": "What is a Distinguished Name?"
        },
        {
            "location": "/adapter/ldap/#the-gory-details-what-happens-in-the-authenticate-method",
            "text": "When the  authenticate()  method is called, the adapter iterates over each\nset of server options, passes them to the internal  Zend\\Ldap\\Ldap  instance,\nand calls the  Zend\\Ldap\\Ldap::bind()  method with the username and password\nbeing authenticated.  Zend\\Ldap\\Ldap  checks to see if the username is qualified with a domain\n(e.g., has a domain component like  alice@foo.net  or  FOO\\alice ). If a\ndomain is present, but does not match either of the server's domain names\n(e.g.,  foo.net  or  FOO ), a special exception is thrown and caught by Zend\\Authentication\\Adapter\\Ldap  that causes that server to be ignored, and\nprogression to the next server configured.  If a domain matches, or if the user did not supply a qualified username, Zend\\Ldap\\Ldap  proceeds to try to bind with the supplied credentials. if\nthe bind is unsuccessful,  Zend\\Ldap\\Ldap  throws a Zend\\Ldap\\Exception\\LdapException  which is caught by Zend\\Authentication\\Adapter\\Ldap  and, again, the adapter progresses to the\nnext configured server.  If the bind is successful, server iteration stops, and the adapter's authenticate()  method returns a successful result.  If all configured servers fail to authenticate,  authenticate()  returns a\nfailure result with error messages from the last server consulted.   The username and password parameters of the  Zend\\Authentication\\Adapter\\Ldap \nconstructor represent the credentials being authenticated (i.e., the\ncredentials supplied by the user through your HTML login form). Alternatively,\nthey may also be set with the  setUsername()  and  setPassword()  methods.",
            "title": "The Gory Details: What Happens in the Authenticate Method?"
        },
        {
            "location": "/adapter/ldap/#server-options",
            "text": "Each set of server options in the context of  Zend\\Authentication\\Adapter\\Ldap \nconsists of the following options, which are passed, largely unmodified, to Zend\\Ldap\\Ldap::setOptions() :     Name  Description      host  The hostname of LDAP server that these options represent. This option is required.    port  The port on which the LDAP server is listening. If  useSsl  is  TRUE , the default port value is 636. If  useSsl  is  FALSE , the default port value is 389.    useStartTls  Whether or not the LDAP client should use TLS (aka SSLv2) encrypted transport. A value of  TRUE  is strongly favored in production environments to prevent passwords from be transmitted in clear text. The default value is  FALSE , as servers frequently require that a certificate be installed separately after installation. The  useSsl  and  useStartTls  options are mutually exclusive. The  useStartTls  option should be favored over  useSsl , but not all servers support this newer mechanism.    useSsl  Whether or not the LDAP client should use SSL encrypted transport. The  useSsl  and  useStartTls  options are mutually exclusive, but  useStartTls  should be favored if the server and LDAP client library support it. This value also changes the default port value (see port description above).    username  The DN of the account used to perform account DN lookups. LDAP servers that require the username to be in DN form when performing the \u201cbind\u201d require this option. Meaning, if  bindRequiresDn  is  TRUE , this option is required. This account does not need to be a privileged account; an account with read-only access to objects under the  baseDn  is all that is necessary (and preferred based on the Principle of Least Privilege).    password  The password of the account used to perform account DN lookups. If this option is not supplied, the LDAP client will attempt an \u201canonymous bind\u201d when performing account DN lookups.    bindRequiresDn  Some LDAP servers require that the username used to bind be in DN form like  CN=Alice Baker,OU=Sales,DC=foo,DC=net  (basically all servers except Active Directory). If this option is  TRUE , this instructs  Zend\\Ldap\\Ldap  to automatically retrieve the DN corresponding to the username being authenticated, if it is not already in DN form, and then re-bind with the proper DN. The default value is  FALSE . Currently only Microsoft Active Directory Server (ADS) is known not to require usernames to be in DN form when binding, and therefore this option may be  FALSE  with AD (and it should be, as retrieving the DN requires an extra round trip to the server). Otherwise, this option must be set to  TRUE  (e.g. for OpenLDAP). This option also controls the default  accountFilterFormat  used when searching for accounts. See the  accountFilterFormat  option.    baseDn  The DN under which all accounts being authenticated are located. This option is required. if you are uncertain about the correct baseDn value, it should be sufficient to derive it from the user\u2019s DNS domain using  DC=  components. For example, if the user\u2019s principal name is  alice@foo.net , a  baseDn  of  DC=foo,DC=net  should work. A more precise location (e.g.,  OU=Sales,DC=foo,DC=net ) will be more efficient, however.    accountCanonicalForm  A value of 2, 3, or 4 indicating the form to which account names should be canonicalized after successful authentication. Values are as follows: 2 for traditional username style names (e.g.,  alice ), 3 for backslash-style names (e.g.,  FOO\\alice ) or 4 for principal style usernames (e.g.,  alice@foo.net ). The default value is 4 (e.g.,  alice@foo.net ). For example, with a value of 3, the identity returned by  Zend\\Authentication\\Result::getIdentity()  (and  Zend\\Authentication\\AuthenticationService::getIdentity() , if  Zend\\Authentication\\AuthenticationService  was used) will always be  FOO\\alice , regardless of what form Alice supplied, whether it be  alice ,  alice@foo.net ,  FOO\\alice ,  FoO\\aLicE ,  foo.net\\alice , etc. See the  Account Name Canonicalization  section in the zend-ldap documentation for details. Note that when using multiple sets of server options it is recommended, but not required, that the same  accountCanonicalForm  be used with all server options so that the resulting usernames are always canonicalized to the same form (e.g., if you canonicalize to  EXAMPLE\\username  with an AD server but to  username@example.com  with an OpenLDAP server, that may be awkward for the application\u2019s high-level logic).    accountDomainName  The FQDN domain name for which the target LDAP server is an authority (e.g.,  example.com ). This option is used to canonicalize names so that the username supplied by the user can be converted as necessary for binding. It is also used to determine if the server is an authority for the supplied username (e.g., if  accountDomainName  is  foo.net  and the user supplies  bob@bar.net , the server will not be queried, and a failure will result). This option is not required, but if it is not supplied, usernames in principal name form (e.g.,  alice@foo.net ) are not supported. It is strongly recommended that you supply this option, as there are many use-cases that require generating the principal name form.    accountDomainNameShort  The \u2018short\u2019 domain for which the target LDAP server is an authority (e.g.,  FOO ). Note that there is a 1:1 mapping between the  accountDomainName  and  accountDomainNameShort . This option should be used to specify the NetBIOS domain name for Windows networks, but may also be used by non-AD servers (e.g., for consistency when multiple sets of server options with the backslash style  accountCanonicalForm ). This option is not required but if it is not supplied, usernames in backslash form (e.g.,  FOO\\alice ) are not supported.    accountFilterFormat  The LDAP search filter used to search for accounts. This string is a  printf() -style expression that must contain one  %s  to accommodate the username. The default value is  (&(objectClass=user)(sAMAccountName=%s)) , unless  bindRequiresDn  is set to  TRUE , in which case the default is  (&(objectClass=posixAccount)(uid=%s)) . For example, if for some reason you wanted to use  bindRequiresDn = true  with AD you would need to set  accountFilterFormat = '(&(objectClass=user)(sAMAccountName=%s))' .    optReferrals  If set to  TRUE , this option indicates to the LDAP client that referrals should be followed. The default value is  FALSE .",
            "title": "Server Options"
        },
        {
            "location": "/adapter/ldap/#tls-and-ssl",
            "text": "If you enable  useStartTls = TRUE  or  useSsl = TRUE  you may find that the\nLDAP client generates an error claiming that it cannot validate the server's\ncertificate. Assuming the PHP LDAP extension is ultimately linked to the\nOpenLDAP client libraries, to resolve this issue you can set  TLS_REQCERT\nnever  in the OpenLDAP client  ldap.conf  (and restart the web server) to\nindicate to the OpenLDAP client library that you trust the server.\nAlternately, if you are concerned that the server could be spoofed, you can\nexport the LDAP server's root certificate and put it on the web server so\nthat the OpenLDAP client can validate the server's identity.",
            "title": "TLS and SSL"
        },
        {
            "location": "/adapter/ldap/#collecting-debugging-messages",
            "text": "Zend\\Authentication\\Adapter\\Ldap  collects debugging information within its authenticate()  method. This information is stored in the Zend\\Authentication\\Result  object as messages. The array returned by Zend\\Authentication\\Result::getMessages()  is described as follows:     Messages Array Index  Description      Index 0  A generic, user-friendly message that is suitable for displaying to users (e.g., \"Invalid credentials\"). If the authentication is successful, this string is empty.    Index 1  A more detailed error message that is not suitable to be displayed to users but should be logged for the benefit of server operators. If the authentication is successful, this string is empty.    Indexes 2 and higher  All log messages in order starting at index 2.     In practice, index 0 should be displayed to the user (e.g., using the FlashMessenger helper ),\nindex 1 should be logged and, if debugging information is being collected,\nindexes 2 and higher could be logged as well (although the final message always\nincludes the string from index 1).",
            "title": "Collecting Debugging Messages"
        },
        {
            "location": "/adapter/ldap/#common-options-for-specific-servers",
            "text": "",
            "title": "Common Options for Specific Servers"
        },
        {
            "location": "/adapter/ldap/#options-for-active-directory",
            "text": "For AD*, the following options are noteworthy:     Name  Additional Notes      host  As with all servers, this option is required.    useStartTls  For the sake of security, this should be  TRUE  if the server has the necessary certificate installed.    useSsl  Possibly used as an alternative to  useStartTls  (see above).    baseDn  As with all servers, this option is required. By default, AD places all user accounts under the Users container (e.g.,  CN=Users,DC=foo,DC=net ), but the default is not common in larger organizations. Ask your AD administrator what the best DN for accounts for your application would be.    accountCanonicalForm  You almost certainly want this to be 3 for backslash style names (e.g.,  FOO\\alice ), which are most familiar to Windows users. You should not use the unqualified form 2 (e.g.,  alice ), as this may grant access to your application to users with the same username in other trusted domains (e.g.,  BAR\\alice  and  FOO\\alice  will be treated as the same user). (See also note below.)    accountDomainName  This is required with AD unless  accountCanonicalForm  2 is used, which, again, is discouraged.    accountDomainNameShort  The NetBIOS name of the domain that users are in and for which the AD server is an authority. This is required if the backslash style  accountCanonicalForm  is used.",
            "title": "Options for Active Directory"
        },
        {
            "location": "/adapter/ldap/#use-qualified-account-names",
            "text": "Technically there should be no danger of accidental cross-domain\nauthentication with the current  Zend\\Authentication\\Adapter\\Ldap \nimplementation, since server domains are explicitly checked, but this may not\nbe true of a future implementation that discovers the domain at runtime, or\nif an alternative adapter is used (e.g., Kerberos). In general, account name\nambiguity is known to be the source of security issues, so always try to use\nqualified account names.",
            "title": "Use qualified account names"
        },
        {
            "location": "/adapter/ldap/#options-for-openldap",
            "text": "For OpenLDAP or a generic LDAP server using a typical posixAccount style\nschema, the following options are noteworthy:     Name  Additional Notes      host  As with all servers, this option is required.    useStartTls  For the sake of security, this should be  TRUE  if the server has the necessary certificate installed.    useSsl  Possibly used as an alternative to  useStartTls  (see above).    username  Required and must be a DN, as OpenLDAP requires that usernames be in DN form when performing a bind. Try to use an unprivileged account.    password  The password corresponding to the username above, but this may be omitted if the LDAP server permits an anonymous binding to query user accounts.    bindRequiresDn  Required and must be TRUE, as OpenLDAP requires that usernames be in DN form when performing a bind.    baseDn  As with all servers, this option is required and indicates the DN under which all accounts being authenticated are located.    accountCanonicalForm  Optional, but the default value is 4 (principal style names like  alice@foo.net ), which may not be ideal if your users are used to backslash style names (e.g.,  FOO\\alice ). For backslash style names, use value 3.    accountDomainName  Required unless you're using  accountCanonicalForm  2, which is not recommended.    accountDomainNameShort  If AD is not also being used, this value is not required. Otherwise, if  accountCanonicalForm  3 is used, this option is required and should be a short name that corresponds adequately to the  accountDomainName  (e.g., if your  accountDomainName  is  foo.net , a good  accountDomainNameShort  value might be  FOO ).",
            "title": "Options for OpenLDAP"
        },
        {
            "location": "/storage/",
            "text": "Identity Persistence\n\n\nAuthenticating a request that includes authentication credentials is useful, but\nit is also often useful to persist the authenticated identity between requests, so\nthe user does not need to provide credentials with each request.\n\n\nHTTP is a stateless protocol; however, techniques such as cookies and sessions\nhave been developed in order to facilitate maintaining state across multiple\nrequests in server-side web applications.\n\n\nDefault Persistence in the PHP Session\n\n\nBy default, zend-authentication provides persistent storage of the identity from a successful\nauthentication attempt using PHP session facilities. Upon a successful authentication attempt,\n\nZend\\Authentication\\AuthenticationService::authenticate()\n stores the identity from the\nauthentication result into persistent storage. Unless specified otherwise,\n\nZend\\Authentication\\AuthenticationService\n uses a storage class named\n\nZend\\Authentication\\Storage\\Session\n, which depends on\n\nzend-session\n.\n\n\nYou may also implement \nZend\\Authentication\\Storage\\StorageInterface\n, and\nprovide your implementation to \nZend\\Authentication\\AuthenticationService::setStorage()\n.\n\n\n\n\nBypass the AuthenticationService\n\n\nIf automatic persistent storage of the identity is not appropriate for your\nuse case, you can skip usage of \nZend\\Authentication\\AuthenticationService\n\naltogether, and instead use an adapter directly.\n\n\n\n\nModifying the Session Namespace\n\n\nZend\\Authentication\\Storage\\Session\n uses the session namespace \nZend_Auth\n.\nThis namespace may be overridden by passing a different value to the constructor\nof \nZend\\Authentication\\Storage\\Session\n, and this value is internally passed\nalong to the constructor of \nZend\\Session\\Container\n.\nThis should occur before authentication is attempted, since\n\nZend\\Authentication\\AuthenticationService::authenticate()\n injects the\nauthenticated identity into the configured storage.\n\n\nuse Zend\\Authentication\\AuthenticationService;\nuse Zend\\Authentication\\Storage\\Session as SessionStorage;\n\n$auth = new AuthenticationService();\n\n// Use 'someNamespace' instead of 'Zend_Auth'\n$auth->setStorage(new SessionStorage('someNamespace'));\n\n// Set up the auth adapter, $authAdapter\n$authAdapter = /* ... */;\n\n// Authenticate, saving the result, and persisting the identity on success:\n$result = $auth->authenticate($authAdapter);\n\n\n\nChain Storage\n\n\nA website might use multiple storage strategies for identity persistence; the\n\nChain\n Storage can be used to glue these together.\n\n\nFor example, the \nChain\n can be configured to first use \nSession\n storage and\nthen use an \nOAuth\n storage adapter. One could configure this in the following\nway:\n\n\n$storage = new Chain;\n$storage->add(new Session);\n$storage->add(new OAuth);   // Note: imaginary storage, not part of zend-authentication\n\n\n\nWhen the \nChain\n Storage is used, its underlying storage adapters will be\nconsulted in the order in which they were added to the chain. Using our scenario\nabove, the \nSession\n storage adapter will be consulted first. When that happens:\n\n\n\n\nIf the \nSession\n storage is non-empty, the \nChain\n will use and return its\n  contents.\n\n\nIf the \nSession\n storage is empty, the \nChain\n will move on to the \nOAuth\n\n  storage adapter.\n\n\nIf the \nOAuth\n storage is empty, the \nChain\n will return an empty result.\n\n\nIf the \nOAuth\n storage is non-empty, the \nChain\n will use and return its\n  contents. However, it will \nalso\n populate all storage adapters with higher\n  priority with the contents; in our example, the \nSession\n storage will be\n  populated, but if we'd added any adapters after the \nOAuth\n adapter, they\n  would not.\n\n\n\n\nThe priority of storage adapters in the Chain can be made explicit via the\n\nChain::add\n method, which accepts a second argument indicating the priority.\n(Per standard priority queue usage, higher values have higher priority, and\nlower or negative values have lower priority.)\n\n\n$chain->add(new A, 2);\n$chain->add(new B, 10); // B will be used first\n\n\n\nImplementing Custom Storage\n\n\nSometimes developers may need to use a different identity storage mechanism than\nthat provided by \nZend\\Authentication\\Storage\\Session\n. To do so, implement\n\nZend\\Authentication\\Storage\\StorageInterface\n and supply an instance of your\nimplementation to \nZend\\Authentication\\AuthenticationService::setStorage()\n.\n\n\nThe following examples demonstrate the process.\n\n\nFirst, implement \nZend\\Authentication\\Storage\\StorageInterface\n:\n\n\n<?php\nnamespace My;\n\nuse Zend\\Authentication\\Storage\\StorageInterface;\n\nclass Storage implements StorageInterface\n{\n    /**\n     * Returns true if and only if storage is empty.\n     *\n     * @return boolean\n     * @throws \\Zend\\Authentication\\Exception\\ExceptionInterface If it is\n     *     impossible to determine whether storage is empty.\n     */\n    public function isEmpty()\n    {\n        /**\n         * @todo implementation\n         */\n    }\n\n    /**\n     * Returns the contents of storage.\n     *\n     * Behavior is undefined when storage is empty.\n     *\n     * @return mixed\n     * @throws \\Zend\\Authentication\\Exception\\ExceptionInterface If reading\n     *     contents from storage is impossible\n     */\n\n    public function read()\n    {\n        /**\n         * @todo implementation\n         */\n    }\n\n    /**\n     * Writes $contents to storage.\n     *\n     * @param  mixed $contents\n     * @return void\n     * @throws \\Zend\\Authentication\\Exception\\ExceptionInterface If writing\n     *     $contents to storage is impossible\n     */\n\n    public function write($contents)\n    {\n        /**\n         * @todo implementation\n         */\n    }\n\n    /**\n     * Clears contents from storage.\n     *\n     * @return void\n     * @throws \\Zend\\Authentication\\Exception\\ExceptionInterface If clearing\n     *     contents from storage is impossible.\n     */\n\n    public function clear()\n    {\n        /**\n         * @todo implementation\n         */\n    }\n}\n\n\n\nIn order to use this custom storage class, \nZend\\Authentication\\AuthenticationService::setStorage()\n\nis invoked before an authentication query is attempted:\n\n\nuse My\\Storage;\nuse Zend\\Authentication\\AuthenticationService;\n\n// Create the authentication service instance:\n$auth = new AuthenticationService();\n\n// Instruct the authentication service to use the custom storage class:\n$auth->setStorage(new Storage());\n\n// Create the authentication adapter:\n$adapter = /* ... */;\n\n// Authenticate, saving the result, and persisting the identity on success:\n$result = $auth->authenticate($adapter);",
            "title": "Identity Persistence"
        },
        {
            "location": "/storage/#identity-persistence",
            "text": "Authenticating a request that includes authentication credentials is useful, but\nit is also often useful to persist the authenticated identity between requests, so\nthe user does not need to provide credentials with each request.  HTTP is a stateless protocol; however, techniques such as cookies and sessions\nhave been developed in order to facilitate maintaining state across multiple\nrequests in server-side web applications.",
            "title": "Identity Persistence"
        },
        {
            "location": "/storage/#default-persistence-in-the-php-session",
            "text": "By default, zend-authentication provides persistent storage of the identity from a successful\nauthentication attempt using PHP session facilities. Upon a successful authentication attempt, Zend\\Authentication\\AuthenticationService::authenticate()  stores the identity from the\nauthentication result into persistent storage. Unless specified otherwise, Zend\\Authentication\\AuthenticationService  uses a storage class named Zend\\Authentication\\Storage\\Session , which depends on zend-session .  You may also implement  Zend\\Authentication\\Storage\\StorageInterface , and\nprovide your implementation to  Zend\\Authentication\\AuthenticationService::setStorage() .",
            "title": "Default Persistence in the PHP Session"
        },
        {
            "location": "/storage/#bypass-the-authenticationservice",
            "text": "If automatic persistent storage of the identity is not appropriate for your\nuse case, you can skip usage of  Zend\\Authentication\\AuthenticationService \naltogether, and instead use an adapter directly.",
            "title": "Bypass the AuthenticationService"
        },
        {
            "location": "/storage/#modifying-the-session-namespace",
            "text": "Zend\\Authentication\\Storage\\Session  uses the session namespace  Zend_Auth .\nThis namespace may be overridden by passing a different value to the constructor\nof  Zend\\Authentication\\Storage\\Session , and this value is internally passed\nalong to the constructor of  Zend\\Session\\Container .\nThis should occur before authentication is attempted, since Zend\\Authentication\\AuthenticationService::authenticate()  injects the\nauthenticated identity into the configured storage.  use Zend\\Authentication\\AuthenticationService;\nuse Zend\\Authentication\\Storage\\Session as SessionStorage;\n\n$auth = new AuthenticationService();\n\n// Use 'someNamespace' instead of 'Zend_Auth'\n$auth->setStorage(new SessionStorage('someNamespace'));\n\n// Set up the auth adapter, $authAdapter\n$authAdapter = /* ... */;\n\n// Authenticate, saving the result, and persisting the identity on success:\n$result = $auth->authenticate($authAdapter);",
            "title": "Modifying the Session Namespace"
        },
        {
            "location": "/storage/#chain-storage",
            "text": "A website might use multiple storage strategies for identity persistence; the Chain  Storage can be used to glue these together.  For example, the  Chain  can be configured to first use  Session  storage and\nthen use an  OAuth  storage adapter. One could configure this in the following\nway:  $storage = new Chain;\n$storage->add(new Session);\n$storage->add(new OAuth);   // Note: imaginary storage, not part of zend-authentication  When the  Chain  Storage is used, its underlying storage adapters will be\nconsulted in the order in which they were added to the chain. Using our scenario\nabove, the  Session  storage adapter will be consulted first. When that happens:   If the  Session  storage is non-empty, the  Chain  will use and return its\n  contents.  If the  Session  storage is empty, the  Chain  will move on to the  OAuth \n  storage adapter.  If the  OAuth  storage is empty, the  Chain  will return an empty result.  If the  OAuth  storage is non-empty, the  Chain  will use and return its\n  contents. However, it will  also  populate all storage adapters with higher\n  priority with the contents; in our example, the  Session  storage will be\n  populated, but if we'd added any adapters after the  OAuth  adapter, they\n  would not.   The priority of storage adapters in the Chain can be made explicit via the Chain::add  method, which accepts a second argument indicating the priority.\n(Per standard priority queue usage, higher values have higher priority, and\nlower or negative values have lower priority.)  $chain->add(new A, 2);\n$chain->add(new B, 10); // B will be used first",
            "title": "Chain Storage"
        },
        {
            "location": "/storage/#implementing-custom-storage",
            "text": "Sometimes developers may need to use a different identity storage mechanism than\nthat provided by  Zend\\Authentication\\Storage\\Session . To do so, implement Zend\\Authentication\\Storage\\StorageInterface  and supply an instance of your\nimplementation to  Zend\\Authentication\\AuthenticationService::setStorage() .  The following examples demonstrate the process.  First, implement  Zend\\Authentication\\Storage\\StorageInterface :  <?php\nnamespace My;\n\nuse Zend\\Authentication\\Storage\\StorageInterface;\n\nclass Storage implements StorageInterface\n{\n    /**\n     * Returns true if and only if storage is empty.\n     *\n     * @return boolean\n     * @throws \\Zend\\Authentication\\Exception\\ExceptionInterface If it is\n     *     impossible to determine whether storage is empty.\n     */\n    public function isEmpty()\n    {\n        /**\n         * @todo implementation\n         */\n    }\n\n    /**\n     * Returns the contents of storage.\n     *\n     * Behavior is undefined when storage is empty.\n     *\n     * @return mixed\n     * @throws \\Zend\\Authentication\\Exception\\ExceptionInterface If reading\n     *     contents from storage is impossible\n     */\n\n    public function read()\n    {\n        /**\n         * @todo implementation\n         */\n    }\n\n    /**\n     * Writes $contents to storage.\n     *\n     * @param  mixed $contents\n     * @return void\n     * @throws \\Zend\\Authentication\\Exception\\ExceptionInterface If writing\n     *     $contents to storage is impossible\n     */\n\n    public function write($contents)\n    {\n        /**\n         * @todo implementation\n         */\n    }\n\n    /**\n     * Clears contents from storage.\n     *\n     * @return void\n     * @throws \\Zend\\Authentication\\Exception\\ExceptionInterface If clearing\n     *     contents from storage is impossible.\n     */\n\n    public function clear()\n    {\n        /**\n         * @todo implementation\n         */\n    }\n}  In order to use this custom storage class,  Zend\\Authentication\\AuthenticationService::setStorage() \nis invoked before an authentication query is attempted:  use My\\Storage;\nuse Zend\\Authentication\\AuthenticationService;\n\n// Create the authentication service instance:\n$auth = new AuthenticationService();\n\n// Instruct the authentication service to use the custom storage class:\n$auth->setStorage(new Storage());\n\n// Create the authentication adapter:\n$adapter = /* ... */;\n\n// Authenticate, saving the result, and persisting the identity on success:\n$result = $auth->authenticate($adapter);",
            "title": "Implementing Custom Storage"
        },
        {
            "location": "/validator/",
            "text": "Authentication Validator\n\n\nZend\\Authentication\\Validator\\Authentication\n provides a \nzend-validator\n\n\nValidatorInterface\n implementation, which can be used within an\n\ninput filter\n or\n\nform\n, or anywhere you\nyou simply want a true/false value to determine whether or not authentication\ncredentials were provided.\n\n\nThe available configuration options include:\n\n\n\n\nadapter\n: an instance of \nZend\\Authentication\\Adapter\\AdapterInterface\n.\n\n\nidentity\n: the identity or name of the identity field in the provided context.\n\n\ncredential\n: credential or the name of the credential field in the provided context.\n\n\nservice\n: an instance of \nZend\\Authentication\\AuthenticationService\n.\n\n\n\n\nUsage\n\n\nuse My\\Authentication\\Adapter;\nuse Zend\\Authentication\\AuthenticationService;\nuse Zend\\Authentication\\Validator\\Authentication as AuthenticationValidator;\n\n$service   = new AuthenticationService();\n$adapter   = new Adapter();\n$validator = new AuthenticationValidator([\n    'service' => $service,\n    'adapter' => $adapter,\n]);\n\n$validator->setCredential('myCredentialContext');\n$validator->isValid('myIdentity', [\n     'myCredentialContext' => 'myCredential',\n]);",
            "title": "Validation"
        },
        {
            "location": "/validator/#authentication-validator",
            "text": "Zend\\Authentication\\Validator\\Authentication  provides a  zend-validator  ValidatorInterface  implementation, which can be used within an input filter  or form , or anywhere you\nyou simply want a true/false value to determine whether or not authentication\ncredentials were provided.  The available configuration options include:   adapter : an instance of  Zend\\Authentication\\Adapter\\AdapterInterface .  identity : the identity or name of the identity field in the provided context.  credential : credential or the name of the credential field in the provided context.  service : an instance of  Zend\\Authentication\\AuthenticationService .",
            "title": "Authentication Validator"
        },
        {
            "location": "/validator/#usage",
            "text": "use My\\Authentication\\Adapter;\nuse Zend\\Authentication\\AuthenticationService;\nuse Zend\\Authentication\\Validator\\Authentication as AuthenticationValidator;\n\n$service   = new AuthenticationService();\n$adapter   = new Adapter();\n$validator = new AuthenticationValidator([\n    'service' => $service,\n    'adapter' => $adapter,\n]);\n\n$validator->setCredential('myCredentialContext');\n$validator->isValid('myIdentity', [\n     'myCredentialContext' => 'myCredential',\n]);",
            "title": "Usage"
        }
    ]
}